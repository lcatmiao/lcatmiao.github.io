[
  
  {
    "title": "Jekyll Chirpy theme + Github搭建个人博客",
    "url": "/posts/Jekyll-Chirpy-theme-+-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/",
    "categories": "学习, 杂知识",
    "tags": "Jekyll",
    "date": "2022-02-05 14:43:00 +0800",
    





    "snippet": "本地写了不少markdown笔记，一直想自己建一个网站。最初的想法是完完全全自己写一个个人网站，全部自定义，不仅可以有技术笔记栏目还可以有其它记录感想，发表观点，发布工具的栏目。然而时间并不总是能自定义，总有些更优先的事项排在前面，加之自己技术水平还没成长到这个程度，于是退而求其次，选择已有框架搭建一个个人博客，先用之，毕竟都要毕业了，连个像样的博客都没有，实在说不过去。我并未放弃建站的想法，说不定以后就有了。安装博客生成器由于kali环境齐全，所以直接在kali下安装本地博客# 安装jekyllsudo gem install jekyll# 安装chirpy主题git clone git@github.com:cotes2020/jekyll-theme-chirpy.git# 在jekyll-theme-chirpy目录下安装依赖# 不需要sudo，命令会在需要时自动调用sudobundle installjekyll-theme-chirpy文件夹就是一个博客生成器，接下来生成本地初始博客。生成初始博客生成博客# 在jekyll-theme-chirpy目录下生成博客，站点取名为lcatmiao.github.io，这里我取的名与后面要创建的# 远程库的名字一致，其实也可以不一致。# jekyll serve命令自动生成名为_site的站点。-d指定生成路径，同时可以重命名站点文件夹名字。sudo jekyll serve -d lcatmiao.github.io# 然后Ctrl + C关闭服务可以看到已经生成了初始博客lcatmiao.github.io# 再次执行jekyll serve命令，这次我们看一下初始博客的样子再关闭服务。# 下面的命令会再一次生成lcatmiao.github.io文件夹，覆盖现有的，反正我们没做什么更改，覆盖就覆盖，无# 妨。# 默认情况下，只有本机才能访问jekyll服务，同一局域网下的其它主机访问不了。加上--host 0.0.0.0后同一局# 域网下的其它主机就可以访问服务了。这里我的kali是虚拟机，与本机之间是NAT模式。执行下面的命令后，可以# 在本机的浏览器中访问kali的网页。sudo jekyll serve -d lcatmiao.github.io --host 0.0.0.0本机浏览器中输入虚拟机IP，端口号4000，可以浏览到初始博客的样子。关闭服务。创建远程库关于github不多赘述。登录github，创建空仓库，为公开库，名字必须为username.github.io，username为github的用户名。推送初始博客# 进入本地lcatmiao.github.io目录# 初始化本地库sudo git init# 添加暂存区sudo git add .# 提交本地库sudo git commit -m &quot;Initialize the blog&quot; .# 添加远程库sudo git remote add lcatmiao.github.io 库链接# 详细查看远程库sudo git remote -v# 推送远程库sudo git push lcatmiao.github.io master刷新远程库，可以看见初始博客已经被推送上来，访问username.github.io就能访问到自己的初始博客页面。修改配置改_config.yml在jekyll-theme-chirpy目录下修改_config.yml。该文件中的注释描述很清楚，自己看着改。配合 jekyll serve 命令在本地查看修改后页面的效果。改faviconfavicon路径：jekyll-theme-chirpy/assets/img/favicons/准备好图片，然后在https://realfavicongenerator.net/生成，下载后解压，在解压后的文件夹中删除browserconfig.xml和site.webmanifest，然后将剩下的东西复制到jekyll-theme-chirpy/assets/img/favicons/删除最近更新栏最近更新栏似乎没有正常工作，查了很多资料也测试了很久，不知道问题出哪了，我决定删除它。在jekyll-theme-chirpy/_layouts/page.html中  &amp;lt;!-- pannel --&amp;gt;  &amp;lt;div id=&quot;panel-wrapper&quot; class=&quot;col-xl-3 pl-2 text-muted&quot;&amp;gt;    &amp;lt;div class=&quot;access&quot;&amp;gt;      {% include update-list.html %}      {% include trending-tags.html %}    &amp;lt;/div&amp;gt;    {% for _include in layout.pannel_includes %}      {% assign _include_path = _include | append: &#39;.html&#39; %}      {% include {{ _include_path }} %}    {% endfor %}  &amp;lt;/div&amp;gt;删除{% include update-list.html %}推送远程库# 在lcatmiao.github.io目录下sudo git add .sudo git commit -m &quot;Personalize some configs&quot; .sudo git push lcatmiao.github.io master访问username.github.io查看页面。放上内容放入自己的文章jekyll-theme-chirpy/_posts就是我们放置md文件的位置。该目录下已有一些文章，这些是博客主题自带的教程，我们不删除，将它们重命名，在每一个文件名前加一个 # ，这样既可以保留这些文件，又可以避免在博客中呈现它们。下面就可以把我们自己的md文件放进去，md文件可以加上一个 yaml头 ，以启用更多功能。关于 yaml头，直接打开这几个主题自带的md文件看看怎么写就行。放入自己的md后，按照主题自带md文件的命名格式命名。# 重新生成博客站点，打开服务# 在jekyll-theme-chirpy下sudo jekyll serve -d lcatmiao.github.io --host 0.0.0.0本地浏览新生成的页面。推送远程库# 在lcatmiao.github.io下sudo git add .sudo git commit .# commit msgAdd git如何合并分支.mdRename the theme&#39;s own md files so that I can keep them and avoid presenting them inthe blog. Besides, add my own md file, git如何合并分支.md.# 推送远程库sudo git push lcatmiao.github.io masterwindows备份因为博客生成器和博客站点都放在虚拟机kali中，而虚拟机经常要回滚，所以我将整个jekyll-theme-chirpy目录在本机windows中备份一份。附jekyll命令# 打开服务，只有本机能够访问网站# 会生成_site目录# 自动监测变化jekyll serve# 指定生成路径和目录名jekyll serve -d ~/myblog# 局域网内其它主机可访问网站jekyll serve --host 0.0.0.0# 指定端口jekyll serve --port 4001# 后台运行# 不能监测变化jekyll serve --detach"
  },
  
  {
    "title": "git如何合并分支",
    "url": "/posts/git%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/",
    "categories": "学习, git",
    "tags": "git",
    "date": "2022-01-26 13:49:37 +0800",
    





    "snippet": "复制了官网文档中对git合并过程的描述，提取了有必要记录的部分；自己测试了一些关于合并冲突的例子，做一个简要总结。  参考资料：Git 分支 - 分支的新建与合并合并过程快进(fast-forward)现在要将hotfix分支合并到master分支。$ git checkout master$ git merge hotfixUpdating f42c576..3a0874cFast-forward index.html | 2 ++ 1 file changed, 2 insertions(+)合并后如下图：当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。随后可以删除hotfix分支。$ git branch -d hotfix三方合并现在要将iss53分支合并到master分支。$ git checkout masterSwitched to branch &#39;master&#39;$ git merge iss53Merge made by the &#39;recursive&#39; strategy.index.html |    1 +1 file changed, 1 insertion(+)合并后如下图：在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的公共祖先（C2），做一个简单的三方合并。Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。随后可以删除iss53分支。$ git branch -d iss53合并冲突如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们，即会产生合并冲突。  fast-forward 一定不会产生合并冲突。  三方合并可能产生合并冲突。合并冲突的发生有点玄学，不必过于纠结，按照第一段话理解即可。具体会不会发生冲突，老老实实听git的就行，它说冲突那就是冲突了。附上一些实测例子：  git版本：git version 2.34.1.windows.1例一直接fast-forward例二PS E:\\2.学习\\test&amp;gt; git merge hotfixAuto-merging merge.txtMerge made by the &#39;ort&#39; strategy. merge.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)我的理解：master对第一行做了修改，但hotfix没有对第一行做修改，无冲突；两分支都没有对第二行做修改，无冲突；master没有对第三行做修改，但hotfix对第三行做了修改，无冲突。最后合并成功，没有冲突。例三PS E:\\2.学习\\test&amp;gt; git merge hotfixAuto-merging merge.txtCONFLICT (content): Merge conflict in merge.txtAutomatic merge failed; fix conflicts and then commit the result.&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEADqwe222qwe=======qweqwe444&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; hotfixqwe我的理解：这个居然会发生冲突，我是没有想到的。原本应该像例二一样理解，第一行只有master改了，第二行只有hotfix改了，第三行两个分支都没改，应该不会出现冲突。然而却出现了冲突，说明冲突的判定没有想象得那么简单，与git的具体实现有关。这里贴出了git插入的冲突标记。按我的理解，根据冲突标记，git认为两个分支对merge.txt的红框处做了不同修改，产生了冲突；蓝框处两者都没有修改，无冲突；所以最终发生了合并冲突。例四PS E:\\2.学习\\test&amp;gt; git merge hotfixAuto-merging merge.txtCONFLICT (content): Merge conflict in merge.txtAutomatic merge failed; fix conflicts and then commit the result.qwe&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEADqwe222qwe=======qweqwe444&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; hotfix同例三。例五PS E:\\2.学习\\test&amp;gt; git merge hotfixAuto-merging merge.txtCONFLICT (content): Merge conflict in merge.txtAutomatic merge failed; fix conflicts and then commit the result.&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEADqwe666=======qwe444&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; hotfixqwe333qwe555我的理解：这个好理解。两个分支对第二行、第三行做了相同的修改，没有冲突；两个分支分别对第一行做了不同的修改，有冲突；最终发生合并冲突。例六PS E:\\2.学习\\test&amp;gt; git merge hotfixAuto-merging merge.txtCONFLICT (content): Merge conflict in merge.txtAutomatic merge failed; fix conflicts and then commit the result.qwe444qwe333&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEADqwe=======qwe555&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; hotfix我的理解：我迷惑了。。。按照之前的理解，两分支对第一行、第二行做了相同的修改，不冲突；master分支没有对第三行做出修改，hotfix分支对第三行做了修改，不冲突；最终应该不冲突才是。假如将这里master分支对第三行的修改看成是“不变的修改”，那么确实可以说两个分支对第三行做了不同的修改，进而发生冲突。但是这样的说法在例二中就站不住脚，按照这个“不变的修改”的假设，例二应该发生冲突才是。想想也是，这个想法是我凭空想象出来的，多半不可能。总结关于合并冲突的判定没有搞懂，不过我认为继续纠结这个问题没有更多的意义了，除非阅读git实现的源码。总而言之，git官方文档的book中有如下描述：Git 分支 - 分支的新建与合并如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。以这句话为标准即可，具体看git的合并结果就行。"
  }
  
]

