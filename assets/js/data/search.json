[
  
  {
    "title": "函数传参",
    "url": "/posts/%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82/",
    "categories": "学习, C_Cpp",
    "tags": "C_Cpp",
    "date": "2022-11-27 23:30:00 +0800",
    





    "snippet": "传参分类从传参类型上看传参分为传值和传指针。  传指针本质上也是传值，只不过传的是指针值。由于传一般值和传指针值还是有点区别，所以分成两种说法。传值一般就指传一般值，传指针专门用于描述传指针值。从传参行为上看传参分为值复制和传自己。  传自己本质上也是值复制，只不过是取地址传无名指针，形参直接接上；而不是直接传有名指针。例如：// 函数调用func1(id, index, flag, &amp;amp;count);func2(arr);// 函数定义头func1(int id, int index, int flag, int *p_count)func2(int *arr)其中，id，index，flag 是值复制，这毫无疑义。arr 是数组名，这里退化为指针，直接进行了传参，也就是我说的“直接传有名指针”，所以我将其归为值复制。&amp;amp;count 是取地址传无名指针，然后形参直接接上，是传自己。传参分析传值是值复制。传指针有两种情况，第一种是值复制，第二种是传自己，如图所示。以下是一些经验，不一定正确，只能说这些场景遇到的比较多，看个眼熟就成。  值复制倾向于使用，传自己倾向于赋值。  一般而言，实参直接传为值复制，实参取地址为传自己。多数情况下，实参取地址可以理解为赋值。  形参中的值变量属于值复制，形参中的指针变量有上图两种情况。（其实就是传参分析的两条，这里着眼于形参。该经验一定正确。）  无论是为了使用还是赋值，传数组一般直接传数组名。  以 char 为例。函数形参中，经常能看见 const char * 和 char * 的使用。const char * 显然不会更改指针所指向内存的内容，但是 char * 就可能更改指针所指向的内容，这一点在实践中值得注意，即我们的内存传递给 char * 后有可能会被更改。更多关于 const 的内容可参看 C_Cpp中的const关键字这里对经验4多说几句。我曾经以为，若是为了给数组赋值，应该对数组名取地址传参。一是因为输出参数一般都加&amp;amp;，写成类似下面这样，一眼就能看出哪些是出参，可读性高。二是觉得平时数组指针的概念都没怎么用过，在这里正好用起来，岂不美哉。// 这是问题写法#include &amp;lt;stdio.h&amp;gt;void func(int, int (*)[], int *);int main(){    int i = 0;    int arr[10] = {0};    int count = 5;    int sum = 0;    func(count, &amp;amp;arr, &amp;amp;sum);    for (i = 0; i &amp;lt; count; i++)    {        printf(&quot;%d\\n&quot;, arr[i]);    }    printf(&quot;sum = %d\\n&quot;, sum);        return 0;}void func(int count, int (*parr)[10], int *p_sum){    int i = 0;    int sum = 0;    for (i = 0; i &amp;lt; count; i++)    {        (*parr)[i] = i;        // parr[0][i] = i;        sum += i;    }    *p_sum = sum;}然而后来我发现了自己的错误，不要这样传参。  原因一：没人这么用。  原因二：memcpy()，snprintf() 这种库函数，平时使用的时候都是直接传数组名的。  原因三：可读性未必好。出参都加了&amp;amp;，算是满足了强迫症，但是函数定义里面就要写成 (*parr)[i] = i 或者 parr[0][i] = i ，这显得复杂。  原因四：性能不佳。使用的时候，(*parr)[i] = i 或者 parr[0][i] = i 要取值两次。  原因五：数组指针有用，但压根不是这么用的。直接传二维数组名的时候，形参就得定义数组指针，这才是数组指针正常的用法。所以给数组名取地址传参是多此一举。上述例子的正确写法应为：// 这是正常写法#include &amp;lt;stdio.h&amp;gt;void func(int, int *, int *);int main(){    int i = 0;    int arr[10] = {0};    int count = 5;    int sum = 0;    func(count, arr, &amp;amp;sum);    for (i = 0; i &amp;lt; count; i++)    {        printf(&quot;%d\\n&quot;, arr[i]);    }    printf(&quot;sum = %d\\n&quot;, sum);        return 0;}void func(int count, int *p, int *p_sum){    int i = 0;    int sum = 0;    for (i = 0; i &amp;lt; count; i++)    {        p[i] = i;        sum += i;    }    *p_sum = sum;}"
  },
  
  {
    "title": "记一次指针强转导致脏数据写入问题",
    "url": "/posts/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8C%87%E9%92%88%E5%BC%BA%E8%BD%AC%E5%AF%BC%E8%87%B4%E8%84%8F%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E9%97%AE%E9%A2%98/",
    "categories": "学习, C_Cpp",
    "tags": "C_Cpp",
    "date": "2022-11-26 11:40:00 +0800",
    





    "snippet": "交接项目的时候遇到的一个问题，涉及指针、字节序、结构体内存对齐相关知识，三大知识包含规则的共同作用导致了这一问题。问题描述时间有些久远了，结合下图来讲，总之，就是变量 vsys_id 莫名其妙地被更改了。当时检查了可能出现问题的相关函数，以及函数传参过程，均没有发现问题所在，甚至在这些地方连 vsys_id 变量名都没有出现，以至于一直没能定位问题。最后发现 vsys_id 被脏数据写入了，也就是说，我们更改变量 policy_id 的同时把 vsys_id 也给改了，从而导致了问题。问题分析根据结构体内存对齐画出结构，可以发现 vsys_id 和 policy_id 是紧挨着的。原先指向 policy_id 的指针是 u16 * ，原代码对其进行了一个强转成 u32 * 的操作，这样一来，这个指针就指向了 policy_id 加 vsys_id 的4个字节，然后原代码对该指针取值赋值1，相当于把这4个字节当成一个变量赋值了。这里似乎是由于传参的时候类型不匹配，于是使用了强转，具体为什么要强转也记不太清了。总之按照正常的逻辑，代码其实是要对 policy_id 赋值成1。强转后赋值的情况如图所示，在X86架构下，的确只是对 policy_id 赋值成1，没什么不对的，所以测试的时候X86架构没啥问题；在MIPS架构下，由于字节序相反，1反而是写给了 vsys_id ，从而引发了问题。  结构体内存对齐这里不赘述，简单来说就是：  成员的偏移量要是自身大小的整数倍，  结构体总大小要是最大成员大小的整数倍。    至于字节序，图中描述已经很清楚。本来是给 policy_id 赋值，却同时改掉了相邻的 vsys_id 的值，也难怪乍一看定位不了问题。最后理解了问题成因，也就顺利解决了。本文对导致该问题的原因做一个记录。"
  },
  
  {
    "title": "C_Cpp中的const关键字",
    "url": "/posts/C_Cpp%E4%B8%AD%E7%9A%84const%E5%85%B3%E9%94%AE%E5%AD%97/",
    "categories": "学习, C_Cpp",
    "tags": "C_Cpp",
    "date": "2022-05-08 21:30:00 +0800",
    





    "snippet": "记录一波 const 关键字的知识点。概述const 意为不可修改。const 修饰的变量不可被修改， 是只读变量，也称这样的变量为常量。const 修饰的变量不可修改这一点是语法层面的限制，通过一些刻意构造的操作仍然可以修改变量的值，只是一般不会这样做。const 也可以修饰指针，既可以限制指针指向的数据，又可以限制指针本身。const 修饰变量const int VexNum = 20;int const VexNum = 20;上述两种写法的效果是一样的。我们一般使用第一种。const 修饰变量，即定义了常量 VexNum。  const 定义的常量一般单词首字母大写。这个时候企图修改常量是不行的。VexNum = 30; // error: assignment of read-only variable &#39;VexNum&#39;由于常量在后期不能被更改，所以定义常量时必须初始化。const 修饰指针const int *p;int const *p;    int * const p = &amp;amp;m;第一、二种写法等效，指针指向的数据不可修改，定义了常量指针；第三种写法是指针本身不可修改，定义了指针常量。  可以这样记忆：const 离指针近，指针本身不可修改，是指针常量；const 离指针远，指针指向的数据不可修改，是常量指针。第一、二种写法定义常量指针，定义时可以不初始化；第三种写法定义指针常量，由于指针常量在后期不能被修改，所以定义指针常量时必须初始化。上述写法本质上是两种写法，这两种写法也可以合到一起，如下：const int * const p = &amp;amp;m;int const * const p = &amp;amp;m;这种写法定义的指针，既是常量指针，又是指针常量。指针本身不能被修改，指针指向的数据也不能被修改。const 和非 const 指针之间的赋值将 const 指针赋值给非 const 指针，不可以。将非 const 指针赋值给 const 指针，可以。  方便记忆：去限制不行，加限制行。const 与字符串写这一块的原因是我发现字符串常量通常都用 const char * 接，但后来发现直接用 char * 接编译也没有报错，一时间产生了诸多疑惑，现将研究结果呈现如下。先说一下字符串。字符串本质上就是字符数组。这里我将字符串分为两类，一类是内存只读的字符数组，一类是内存可读可写的字符数组，前者就是字符串常量，后者可以理解为“字符串变量”。  C语言中并没有“字符串变量”的说法，平时大都直接用字符数组来称呼“字符串变量”，但其实无论是字符串常量还是“字符串变量”，本质上都是字符数组。由于我不喜欢用字符数组来称呼“字符串变量”，所以还是忍不住直接使用了“字符串变量”的说法，读者只要清楚这里的“字符串变量”是指内存可读可写的字符数组就行。我们在代码中直接书写的类似 &quot;abc&quot;，&quot;This is a string.&quot;，&quot;Fail to open db.&quot; 就是字符串常量，除此以外都是“字符串变量”。既然字符串是字符数组，那么指向首元素的指针就是 char *，用 char * 接字符串常量自然能过编译。// 能过编译char *str = &quot;abc&quot;;但是如果企图更改它的值，那就要出问题了。// 能过编译，但运行时会出错#include &amp;lt;stdio.h&amp;gt;int main(){    char *str = &quot;abc&quot;;    *str = &#39;A&#39;;    printf(&quot;%s\\n&quot;, str);        return 0;}字符串常量是内存只读的字符数组，强行改值自然要出问题。正因如此，通常会使用 const 关键字加以编译层面的检查，防止开发者无意间做出更改只读内存的操作。const char *str = &quot;abc&quot;;const 在 C 和 C++ 中的区别编译期替换#include &amp;lt;stdio.h&amp;gt;int main(){    const int m = 20;    int *p = (int *)&amp;amp;m;    *p = 40;    printf(&quot;%d\\n&quot;, m);    printf(&quot;%d\\n&quot;, *p);    return 0;}上述代码中，m 是常量，但我们通过指针仍然更改了它的值。&amp;amp;m 得到的是 const int * 类型，不能直接赋值给 int *，所以这里需要强转。最终我们更改了 m 常量在内存中的值。可见，const 的限制并不是绝对的，通过一些刻意的操作仍然可以修改，只是一般不会这样做。下面说一下 const 在 C 和 C++ 中的区别。上述代码在C中运行的结果如下：4040将同样的代码放到C++中运行：#include &amp;lt;iostream&amp;gt;using namespace std;int main(){    const int m = 20;    int *p = (int *)&amp;amp;m;    *p = 40;    cout &amp;lt;&amp;lt; m &amp;lt;&amp;lt; endl;    cout &amp;lt;&amp;lt; *p &amp;lt;&amp;lt; endl;    return 0;}结果为：2040原因在于：C++中的 `const` 会进行编译期替换，有点类似 #define，但 #define 是在预处理阶段。我们可以理解为，C++的代码，在经过编译后，变成了如下：#include &amp;lt;iostream&amp;gt;using namespace std;int main(){    const int m = 20;    int *p = (int *)&amp;amp;m;    *p = 40;    cout &amp;lt;&amp;lt; 20 &amp;lt;&amp;lt; endl;    cout &amp;lt;&amp;lt; *p &amp;lt;&amp;lt; endl;    return 0;}实际上 m 在内存中的值的确被改为了 40，只不过由于编译期替换，我们 cout &amp;lt;&amp;lt; m 直接变成了 cout &amp;lt;&amp;lt; 20，自然就输出了 20。而在C中运行时，就是正常执行，printf(&quot;%d\\n&quot;, m) 中 m 还是变量 m，程序读取变量 m 的值，发现是 40，就输出 40。C++少了读取变量内存的过程，提高了执行效率，但不能及时反应变量的修改；然而，一般也不会修改 const 变量。可见范围在C语言中，const 全局变量和普通全局变量一样，作用域是整个工程，只不过需要用 extern 声明一下才能在其它文件中使用。见如下代码：test1.c#include &amp;lt;stdio.h&amp;gt;extern const int m;int main(){    printf(&quot;%d\\n&quot;, m);    return 0;}test2.cconst int m = 20;编译命令：gcc test1.c test2.c -o test运行结果：20我们在 test2.c 中定义了 const 全局变量，在 test1.c 中通过 extern 声明之，便可以使用了。其实这里使用 extern int m; 声明也是可以的，但还是建议使用 extern const int m; 声明，因为使用后者能够启用相关的代码检查，具体说明如下：修改 test1.c 如下：#include &amp;lt;stdio.h&amp;gt;extern const int m;int main(){    // 这里尝试对const变量进行修改，无论是VSCode Linting还是gcc都会报错，这很正常。    m = 40;     printf(&quot;%d\\n&quot;, m);    return 0;}但若修改 test1.c 如下：#include &amp;lt;stdio.h&amp;gt;extern int m;int main(){    // 这里尝试对const变量进行修改，但无论是VSCode Linting还是gcc都没有报错，    // 但是生成的exe无法正常运行。    m = 40;     printf(&quot;%d\\n&quot;, m);    return 0;}综上所述，推荐使用 extern const int m; 进行声明，这样可以使相关代码检查能够正常工作，而且代码看上去更清楚，可读性更高。稍微扯远了点，现在我们回来，总之，在C语言中，const 全局变量和普通全局变量一样，作用域都是整个工程，只不过需要用 extern 声明一下才能在其它文件中使用。在C++中，`const` 全局变量的作用域仅是单个文件。 见如下代码：test1.cpp#include &amp;lt;iostream&amp;gt;using namespace std;extern const int m;int main(){    cout &amp;lt;&amp;lt; m &amp;lt;&amp;lt; endl;    return 0;}test2.cppconst int m = 20;编译命令：g++ test1.cpp test2.cpp -o test此时编译链接会出现错误：undefined reference to `m&#39;collect2.exe: error: ld returned 1 exit status因为C++中 const 全局变量的作用域仅是单个文件，用 extern 也没用。所以在C++中，下述代码是成立的：test1.cpp#include &amp;lt;iostream&amp;gt;using namespace std;const int m = 20;void func();int main(){    cout &amp;lt;&amp;lt; m &amp;lt;&amp;lt; endl;    func();    return 0;}test2.cpp#include &amp;lt;iostream&amp;gt;using namespace std;const int m = 40;void func(){    cout &amp;lt;&amp;lt; m &amp;lt;&amp;lt; endl;}运行结果：2040上面两个全局变量 m 互不影响，进行编译期替换，自然就能得到上述结果。至于内存，我认为全局区同时存在两个 m，编译器应该通过某种方式区分了它们。在 VSCode 调试中，我也能看到 m 的值既可以是 20，也可以是 40。如下图：当我在 main() 中时，只能看见 test1.cpp 中定义的 m，从全局区读取了 test1.cpp 中定义的 m 为 20。当我在 func() 中时，只能看见 test2.cpp 中定义的 m，从全局区读取了 test2.cpp 中定义的 m 为 40。总之，这样的代码在C中就不能成立，会出现重复定义全局变量的错误。C++中，在定义 `const` 全局变量时加上 `extern` 关键字可以将作用域从单个文件扩展到整个工程，此方法仅 `g++` 支持。 见如下代码：test1.cpp#include &amp;lt;iostream&amp;gt;using namespace std;extern const int m;int main(){    cout &amp;lt;&amp;lt; m &amp;lt;&amp;lt; endl;    return 0;}test2.cppextern const int m = 20;运行结果：20在 test2.cpp 中，使用 extern 定义了 const 全局变量，作用域是整个工程，在 test1.cpp 中使用 extern 声明一下后就可以使用了。const or #define如果只是为了像 const int a = 10;，#define MAX 20 这样定义一个常量，那么 const 和 #define 都可以用来定义。有的资料中说使用 const 定义常量时带了类型，编译时会有类型检查；#define 在预编译阶段只是替换，没有类型检查一说。这点心里有数就行。纯粹只是定义一个常量的话，C语言的风格更多使用 #define；C++两者都会用，const 很常见。"
  },
  
  {
    "title": "MySQL数据类型转换",
    "url": "/posts/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/",
    "categories": "学习, SQL",
    "tags": "SQL",
    "date": "2022-02-11 21:35:00 +0800",
    





    "snippet": "关于MySQL的数据类型转换问题大概两年前就研究过了，只是那时候没有发博客的习惯，笔记记得也很简单。最近又遇到了这个问题，打开以往的笔记发现记得太简单了，自己看完了还是有好多疑问😭，故有了这篇文章。  参考资料：  MySQL :: MySQL 8.0 Reference Manual :: 12.11 Cast Functions and Operators  MySQL :: MySQL 8.0 Reference Manual :: 12.3 Type Conversion in Expression Evaluation  mysql 类型自动化转换问题 - whendream - 博客园  谈谈MySQL隐式类型转换 - 知乎  测试版本：  MySQL 8.0.18显式转换cast()CAST(expr AS type [ARRAY])使用该函数可以进行强制类型转换。type：  signed：signed bigint类型  char：varchar类型  float  double# 将53.4转换为整数mysql&amp;gt; select cast(53.4 as signed);+----------------------+| cast(53.4 as signed) |+----------------------+|                   53 |+----------------------+1 row in set (0.00 sec)# 将53.6转换为整数mysql&amp;gt; select cast(53.6 as signed);+----------------------+| cast(53.6 as signed) |+----------------------+|                   54 |+----------------------+1 row in set (0.00 sec)# 将-53.4转换为整数mysql&amp;gt; select cast(-53.4 as signed);+-----------------------+| cast(-53.4 as signed) |+-----------------------+|                   -53 |+-----------------------+1 row in set (0.00 sec)# 将-53.6转换为整数mysql&amp;gt; select cast(-53.6 as signed);+-----------------------+| cast(-53.6 as signed) |+-----------------------+|                   -54 |+-----------------------+1 row in set (0.00 sec)# 将53.4转换为字符串mysql&amp;gt; select cast(53.4 as char);+--------------------+| cast(53.4 as char) |+--------------------+| 53.4               |+--------------------+1 row in set (0.00 sec)字符串转换为数字的规则      不以数字开头的字符串会被转换为0        以数字开头的字符串会被转换成开头的那些数字  此规则也适用于隐式转换。# 将字符串qwe456转换为整数mysql&amp;gt; select cast(&#39;qwe456&#39; as signed);+--------------------------+| cast(&#39;qwe456&#39; as signed) |+--------------------------+|                        0 |+--------------------------+1 row in set, 1 warning (0.00 sec)# 将字符串123qwe456转换为整数mysql&amp;gt; select cast(&#39;123qwe456&#39; as signed);+-----------------------------+| cast(&#39;123qwe456&#39; as signed) |+-----------------------------+|                         123 |+-----------------------------+1 row in set, 1 warning (0.00 sec)# 将字符串123.66qwe456转换为整数mysql&amp;gt; select cast(&#39;123.66qwe456&#39; as signed);+--------------------------------+| cast(&#39;123.66qwe456&#39; as signed) |+--------------------------------+|                            123 |+--------------------------------+1 row in set, 1 warning (0.00 sec)# 将字符串123.66qwe456转换为浮点数mysql&amp;gt; select cast(&#39;123.66qwe456&#39; as float);+-------------------------------+| cast(&#39;123.66qwe456&#39; as float) |+-------------------------------+|                        123.66 |+-------------------------------+1 row in set, 1 warning (0.00 sec)隐式转换数字与字符串的相互转换MySQL会在必要的时候将数字转换为字符串，或将字符串转换为数字。# 数字转换为字符串mysql&amp;gt; select concat(2, &#39;test&#39;);+-------------------+| concat(2, &#39;test&#39;) |+-------------------+| 2test             |+-------------------+1 row in set (0.00 sec)# 字符串转换为数字mysql&amp;gt; select 1 + &#39;1&#39;;+---------+| 1 + &#39;1&#39; |+---------+|       2 |+---------+1 row in set (0.00 sec)# 字符串转换为数字mysql&amp;gt; select 6 &amp;gt; &#39;3qwe&#39;;+------------+| 6 &amp;gt; &#39;3qwe&#39; |+------------+|          1 |+------------+1 row in set, 1 warning (0.00 sec)# 字符串转换为数字mysql&amp;gt; select 0 = &#39;qwe345&#39;;+--------------+| 0 = &#39;qwe345&#39; |+--------------+|            1 |+--------------+1 row in set, 1 warning (0.00 sec)第一例，concat() 需要的参数为字符串，先将数字 2 转换为字符串 &#39;2&#39; ，再将 &#39;2&#39; 与 &#39;test&#39; 进行拼接得到 &#39;2test&#39; 。第二例，加法运算，先将字符串 &#39;1&#39; 转换为数字 1 ，再做加法得到 2 。第三例，比较运算，先将 &#39;3qwe&#39; 转换为数字 3 ，然后 6 &amp;gt; 3 为真，返回1。第四例，比较运算，先将 &#39;qwe345&#39; 转换为数字 0 ，然后 0 = 0 为真，返回1。下面是第五例的情景：# 有表如下mysql&amp;gt; select * from test1;+-------+-------+-------+| no    | name  | grade |+-------+-------+-------+| 23    | admin |    50 || 24    | admin |    43 || 25    | qwe   |    54 || 25asd | qwe   |    54 |+-------+-------+-------+4 rows in set (0.00 sec)# 表结构如下mysql&amp;gt; desc test1;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| no    | varchar(50) | NO   | PRI | NULL    |       || name  | varchar(50) | YES  |     | NULL    |       || grade | smallint(6) | YES  |     | NULL    |       |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec)# 执行查询如下mysql&amp;gt; select * from test1 where no = 25;+-------+------+-------+| no    | name | grade |+-------+------+-------+| 25    | qwe  |    54 || 25asd | qwe  |    54 |+-------+------+-------+2 rows in set, 1 warning (0.00 sec)上面的情景中，执行 where no = 25 时，先看第一行，将字符串 &#39;23&#39; 转换为数字 23 ， 23 = 25 为假，不选该行；然后一样， 24 = 25 为假，不选该行；第三行，将字符串 &#39;25&#39; 转换为数字 25 ， 25 = 25 为真，选中该行；第四行，将字符串 25asd 转换为数字 25 ， 25 = 25 为真，选中该行；最后得到上面的查询结果。总转换规则下面的规则更详细精确，是来自官方文档的描述。The following rules describe how conversion occurs for comparison operations:      If one or both arguments are NULL, the result of the comparison is NULL, except for the NULL-safe &amp;lt;=&amp;gt; equality comparison operator. For NULL &amp;lt;=&amp;gt; NULL, the result is true. No conversion is needed.        If both arguments in a comparison operation are strings, they are compared as strings.        If both arguments are integers, they are compared as integers.        Hexadecimal values are treated as binary strings if not compared to a number.        If one of the arguments is a TIMESTAMP or DATETIME column and the other argument is a constant, the constant is converted to a timestamp before the comparison is performed. This is done to be more ODBC-friendly. This is not done for the arguments to IN(). To be safe, always use complete datetime, date, or time strings when doing comparisons. For example, to achieve best results when using BETWEEN with date or time values, use CAST() to explicitly convert the values to the desired data type.    A single-row subquery from a table or tables is not considered a constant. For example, if a subquery returns an integer to be compared to a DATETIME value, the comparison is done as two integers. The integer is not converted to a temporal value. To compare the operands as DATETIME values, use CAST() to explicitly convert the subquery value to DATETIME.        If one of the arguments is a decimal value, comparison depends on the other argument. The arguments are compared as decimal values if the other argument is a decimal or integer value, or as floating-point values if the other argument is a floating-point value.        In all other cases, the arguments are compared as floating-point (double-precision) numbers. For example, a comparison of string and numeric operands takes place as a comparison of floating-point numbers.  复制自 mysql 类型自动化转换问题 - whendream - 博客园 的翻译：比较运算时的类型转换规则：  如果一个或两个参数都是NULL，比较的结果是NULL，除了NULL安全的&amp;lt;=&amp;gt;相等比较运算符。对于NULL &amp;lt;=&amp;gt; NULL，结果为true。不需要转换。  如果比较操作中的两个参数都是字符串，则将它们作为字符串进行比较。  如果两个参数都是整数，则将它们作为整数进行比较。  如果不与数字进行比较，则将十六进制值视为二进制字符串。  如果其中一个参数是十进制值，则比较取决于另一个参数。 如果另一个参数是十进制或整数值，则将参数与十进制值进行比较，如果另一个参数是浮点值，则将参数与浮点值进行比较。  如果其中一个参数是TIMESTAMP或DATETIME列，另一个参数是常量，则在执行比较之前将常量转换为时间戳。  我的翻译：在所有其它情况下，参数作为浮点数（双精度）进行比较。例如，字符串和数字的比较就作为浮点数进行比较。"
  },
  
  {
    "title": "Jekyll Chirpy theme + Github搭建个人博客",
    "url": "/posts/Jekyll-Chirpy-theme-+-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/",
    "categories": "学习, 杂知识",
    "tags": "Jekyll",
    "date": "2022-02-05 14:43:00 +0800",
    





    "snippet": "本地写了不少markdown笔记，一直想自己建一个网站。最初的想法是完完全全自己写一个个人网站，全部自定义，不仅可以有技术笔记栏目还可以有其它记录感想，发表观点，发布工具的栏目。然而时间并不总是能自定义，总有些更优先的事项排在前面，加之自己技术水平还没成长到这个程度，于是退而求其次，选择已有框架搭建一个个人博客，先用之，毕竟都要毕业了，连个像样的博客都没有，实在说不过去。我并未放弃建站的想法，说不定以后就有了。安装博客生成器由于kali环境齐全，所以直接在kali下安装本地博客# 安装jekyllsudo gem install jekyll# 安装chirpy主题git clone git@github.com:cotes2020/jekyll-theme-chirpy.git# 在jekyll-theme-chirpy目录下安装依赖# 不需要sudo，命令会在需要时自动调用sudobundle installjekyll-theme-chirpy文件夹就是一个博客生成器，接下来生成本地初始博客。生成初始博客生成博客# 在jekyll-theme-chirpy目录下生成博客，站点取名为lcatmiao.github.io，这里我取的名与后面要创建的# 远程库的名字一致，其实也可以不一致。# jekyll serve命令自动生成名为_site的站点。-d指定生成路径，同时可以重命名站点文件夹名字。sudo jekyll serve -d lcatmiao.github.io# 然后Ctrl + C关闭服务可以看到已经生成了初始博客lcatmiao.github.io# 再次执行jekyll serve命令，这次我们看一下初始博客的样子再关闭服务。# 下面的命令会再一次生成lcatmiao.github.io文件夹，覆盖现有的，反正我们没做什么更改，覆盖就覆盖，无# 妨。# 默认情况下，只有本机才能访问jekyll服务，同一局域网下的其它主机访问不了。加上--host 0.0.0.0后同一局# 域网下的其它主机就可以访问服务了。这里我的kali是虚拟机，与本机之间是NAT模式。执行下面的命令后，可以# 在本机的浏览器中访问kali的网页。sudo jekyll serve -d lcatmiao.github.io --host 0.0.0.0本机浏览器中输入虚拟机IP，端口号4000，可以浏览到初始博客的样子。关闭服务。创建远程库关于github不多赘述。登录github，创建空仓库，为公开库，名字必须为username.github.io，username为github的用户名。推送初始博客# 进入本地lcatmiao.github.io目录# 初始化本地库sudo git init# 添加暂存区sudo git add .# 提交本地库sudo git commit -m &quot;Initialize the blog&quot; .# 添加远程库sudo git remote add lcatmiao.github.io 库链接# 详细查看远程库sudo git remote -v# 推送远程库sudo git push lcatmiao.github.io master刷新远程库，可以看见初始博客已经被推送上来，访问username.github.io就能访问到自己的初始博客页面。修改配置改_config.yml在jekyll-theme-chirpy目录下修改_config.yml。该文件中的注释描述很清楚，自己看着改。配合 jekyll serve 命令在本地查看修改后页面的效果。改faviconfavicon路径：jekyll-theme-chirpy/assets/img/favicons/准备好图片，然后在https://realfavicongenerator.net/生成，下载后解压，在解压后的文件夹中删除browserconfig.xml和site.webmanifest，然后将剩下的东西复制到jekyll-theme-chirpy/assets/img/favicons/删除最近更新栏最近更新栏似乎没有正常工作，查了很多资料也测试了很久，不知道问题出哪了，我决定删除它。在jekyll-theme-chirpy/_layouts/page.html中  &amp;lt;!-- pannel --&amp;gt;  &amp;lt;div id=&quot;panel-wrapper&quot; class=&quot;col-xl-3 pl-2 text-muted&quot;&amp;gt;    &amp;lt;div class=&quot;access&quot;&amp;gt;      {% include update-list.html %}      {% include trending-tags.html %}    &amp;lt;/div&amp;gt;    {% for _include in layout.pannel_includes %}      {% assign _include_path = _include | append: &#39;.html&#39; %}      {% include {{ _include_path }} %}    {% endfor %}  &amp;lt;/div&amp;gt;删除{% include update-list.html %}推送远程库# 在lcatmiao.github.io目录下sudo git add .sudo git commit -m &quot;Personalize some configs&quot; .sudo git push lcatmiao.github.io master访问username.github.io查看页面。放上内容放入自己的文章jekyll-theme-chirpy/_posts就是我们放置md文件的位置。该目录下已有一些文章，这些是博客主题自带的教程，我们不删除，将它们重命名，在每一个文件名前加一个 # ，这样既可以保留这些文件，又可以避免在博客中呈现它们。下面就可以把我们自己的md文件放进去，md文件可以加上一个 yaml头 ，以启用更多功能。关于 yaml头，直接打开这几个主题自带的md文件看看怎么写就行。放入自己的md后，按照主题自带md文件的命名格式命名。# 重新生成博客站点，打开服务# 在jekyll-theme-chirpy下sudo jekyll serve -d lcatmiao.github.io --host 0.0.0.0本地浏览新生成的页面。推送远程库# 在lcatmiao.github.io下sudo git add .sudo git commit .# commit msgAdd git如何合并分支.mdRename the theme&#39;s own md files so that I can keep them and avoid presenting them inthe blog. Besides, add my own md file, git如何合并分支.md.# 推送远程库sudo git push lcatmiao.github.io masterwindows备份因为博客生成器和博客站点都放在虚拟机kali中，而虚拟机经常要回滚，所以我将整个jekyll-theme-chirpy目录在本机windows中备份一份。附jekyll命令# 打开服务，只有本机能够访问网站# 会生成_site目录# 自动监测变化jekyll serve# 指定生成路径和目录名jekyll serve -d ~/myblog# 局域网内其它主机可访问网站jekyll serve --host 0.0.0.0# 指定端口jekyll serve --port 4001# 后台运行# 不能监测变化jekyll serve --detach"
  },
  
  {
    "title": "关于域名的各种名词叫法",
    "url": "/posts/%E5%85%B3%E4%BA%8E%E5%9F%9F%E5%90%8D%E7%9A%84%E5%90%84%E7%A7%8D%E5%90%8D%E8%AF%8D%E5%8F%AB%E6%B3%95/",
    "categories": "学习, 杂知识",
    "tags": "",
    "date": "2022-01-29 17:31:10 +0800",
    





    "snippet": "关于域名有一些名词，比如域名、顶级域名、二级域名、三级域名、子域名、主机名等。自己总是搞不清这些名词具体指代什么，因为网上的资料总是有各种差别，同一个名词在不同的资料里有不同的解释，属实是迷惑。在查阅了很多资料后，决定做一个总结，尽可能涵盖各种说法，做一个自己理解的标准，以期在遇到这些说法时心里有底。资料基本概念 (aliyun.com)Domain name - WikipediaWhat’s in a Domain Name? All About Domain Levels - Hover Blog下面贴两段我认为有帮助的描述阿里云产品文档基本概念 (aliyun.com)互联网名称与数字地址分配机构（ICANN）负责管理和协调国际互联网络域名系统。根据ICANN的定义，一个完整的域名至少有两个部分，各部分之间用“.”来分隔，最后一个“.”的右边部分称为顶级域名，也称为一级域名；最后一个“.”的左边部分称为二级域名；二级域名的左边部分称为三级域名，以此类推，每一级的域名控制它下一级域名的分配。下图以www.example.com.cn为例，为您介绍域名的级别。注册域名过程中，可自定义的内容在域名后缀的左侧部分。根据注册局规则，可供用户选择的后缀，可能是顶级域名（如“.cn”），也可能是二级域名（如“.com.cn/.net.cn/.org.cn”）。域名解析设置是针对已经完成注册的域名或已注册域名的左侧部分（即域名后缀左侧的左侧）进行解析设置。 所以在解析场景下，对用户解析内容设置的到底是第几个左侧的解释会存在困难。因此，解析场景里，用户注册的完整域名被定义为“一级域名”（不是顶级域名），完整域名的左侧第一个（即一级域名的子域名）是二级域名，以此类推。以注册一个后缀为“.org.cn”、完整域名为“sample.org.cn”的域名为例，对各定义进行如下说明。  域名后缀：“.org.cn”为注册局提供的可注册的域名后缀。  一级域名：“sample.org.cn”为用户注册的完整域名，即解析场景下的一级域名。  二级域名：“abc.sample.org.cn”为“sample.org.cn”的子域名，即解析场景下的二级域名。维基百科Domain name - Wikipedia在Purpose的第一段有：Individual Internet host computers use domain names as host identifiers, also called hostnames. The term hostname is also used for the leaf labels in the domain name system, usually without further subordinate domain name space. Hostnames appear as a component in Uniform Resource Locators (URLs) for Internet resources such as websites (e.g., en.wikipedia.org).在Second-level and lower level domains的第三段有：Second-level (or lower-level, depending on the established parent hierarchy) domain names are often created based on the name of a company (e.g., bbc.co.uk), product or service (e.g. hotmail.com). Below these levels, the next domain name component has been used to designate a particular host server. Therefore, ftp.example.com might be an FTP server, www.example.com would be a World Wide Web server, and mail.example.com could be an email server, each intended to perform only the implied function.总结https://www.example.com.cn/detail/index.html?id=6以上面这个链接为例，https是协议 ，/detail/index.html是路径，id=6是参数。www.example.com.cn这一整个是域名，也是主机名；cn是顶级域名（一级域名）；com是二级域名，也可以说com.cn是二级域名；example是三级域名，也可以说example.com.cn是三级域名；www是四级域名，也可以说www.example.com.cn是四级域名。com是cn的子域名，example是com的子域名，example是com.cn的子域名，www是example.com.cn的子域名，www.example.com.cn是example.com.cn的子域名，这里说法比较随意，子域名是一个相对概念，想象一下树结构就行。example.com.cn是花钱买的部分，是用户注册的部分，买来以后可以设置子域名，比如www。www是自定义的名字，是服务名，可用于指明服务器提供的服务，例如www、ftp、mail；还可以叫它主机名，不过这个叫法与上面提到的“整个域名也是主机名”是两回事。本例中，www也是四级域名。我们平时看到的域名大都以com、cn、org单个结尾，类似下面这样：www.baidu.comwww.360.cnwww.kali.org但也有以com.cn、net.cn、org.cn两个结尾的，如：yz.chsi.com.cnwww.yto.net.cnwww.cnvd.org.cn本例www.example.com.cn便是以com.cn两个结尾的。com.cn、net.cn、org.cn这种看作二级域名，而不是作为整体看作顶级域名（一级域名）。域名后缀可以是顶级域名（一级域名），也可以是二级域名，前三个例子中，com、cn、org是域名后缀，后三个例子中，com.cn、net.cn、org.cn是域名后缀。本例www.example.com.cn中com.cn是域名后缀。关于一级域名、二级域名等还有另一种说法。以www.example.com.cn为例。将用户注册的完整域名叫做一级域名（不能叫顶级域名），随后逐级下降。example.com.cn是一级域名；www是二级域名，也可以说www.example.com.cn是二级域名。"
  },
  
  {
    "title": "git如何合并分支",
    "url": "/posts/git%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/",
    "categories": "学习, 杂知识",
    "tags": "git",
    "date": "2022-01-26 13:49:37 +0800",
    





    "snippet": "复制了官网文档中对git合并过程的描述，提取了有必要记录的部分；自己测试了一些关于合并冲突的例子，做一个简要总结。  参考资料：Git 分支 - 分支的新建与合并合并过程快进(fast-forward)现在要将hotfix分支合并到master分支。$ git checkout master$ git merge hotfixUpdating f42c576..3a0874cFast-forward index.html | 2 ++ 1 file changed, 2 insertions(+)合并后如下图：当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。随后可以删除hotfix分支。$ git branch -d hotfix三方合并现在要将iss53分支合并到master分支。$ git checkout masterSwitched to branch &#39;master&#39;$ git merge iss53Merge made by the &#39;recursive&#39; strategy.index.html |    1 +1 file changed, 1 insertion(+)合并后如下图：在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的公共祖先（C2），做一个简单的三方合并。Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。随后可以删除iss53分支。$ git branch -d iss53合并冲突如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们，即会产生合并冲突。  fast-forward 一定不会产生合并冲突。  三方合并可能产生合并冲突。合并冲突的发生有点玄学，不必过于纠结，按照第一段话理解即可。具体会不会发生冲突，老老实实听git的就行，它说冲突那就是冲突了。附上一些实测例子：  git版本：git version 2.34.1.windows.1例一直接fast-forward例二PS E:\\2.学习\\test&amp;gt; git merge hotfixAuto-merging merge.txtMerge made by the &#39;ort&#39; strategy. merge.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)我的理解：master对第一行做了修改，但hotfix没有对第一行做修改，无冲突；两分支都没有对第二行做修改，无冲突；master没有对第三行做修改，但hotfix对第三行做了修改，无冲突。最后合并成功，没有冲突。例三PS E:\\2.学习\\test&amp;gt; git merge hotfixAuto-merging merge.txtCONFLICT (content): Merge conflict in merge.txtAutomatic merge failed; fix conflicts and then commit the result.&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEADqwe222qwe=======qweqwe444&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; hotfixqwe我的理解：这个居然会发生冲突，我是没有想到的。原本应该像例二一样理解，第一行只有master改了，第二行只有hotfix改了，第三行两个分支都没改，应该不会出现冲突。然而却出现了冲突，说明冲突的判定没有想象得那么简单，与git的具体实现有关。这里贴出了git插入的冲突标记。按我的理解，根据冲突标记，git认为两个分支对merge.txt的红框处做了不同修改，产生了冲突；蓝框处两者都没有修改，无冲突；所以最终发生了合并冲突。例四PS E:\\2.学习\\test&amp;gt; git merge hotfixAuto-merging merge.txtCONFLICT (content): Merge conflict in merge.txtAutomatic merge failed; fix conflicts and then commit the result.qwe&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEADqwe222qwe=======qweqwe444&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; hotfix同例三。例五PS E:\\2.学习\\test&amp;gt; git merge hotfixAuto-merging merge.txtCONFLICT (content): Merge conflict in merge.txtAutomatic merge failed; fix conflicts and then commit the result.&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEADqwe666=======qwe444&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; hotfixqwe333qwe555我的理解：这个好理解。两个分支对第二行、第三行做了相同的修改，没有冲突；两个分支分别对第一行做了不同的修改，有冲突；最终发生合并冲突。例六PS E:\\2.学习\\test&amp;gt; git merge hotfixAuto-merging merge.txtCONFLICT (content): Merge conflict in merge.txtAutomatic merge failed; fix conflicts and then commit the result.qwe444qwe333&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEADqwe=======qwe555&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; hotfix我的理解：我迷惑了。。。按照之前的理解，两分支对第一行、第二行做了相同的修改，不冲突；master分支没有对第三行做出修改，hotfix分支对第三行做了修改，不冲突；最终应该不冲突才是。假如将这里master分支对第三行的修改看成是“不变的修改”，那么确实可以说两个分支对第三行做了不同的修改，进而发生冲突。但是这样的说法在例二中就站不住脚，按照这个“不变的修改”的假设，例二应该发生冲突才是。想想也是，这个想法是我凭空想象出来的，多半不可能。总结关于合并冲突的判定没有搞懂，不过我认为继续纠结这个问题没有更多的意义了，除非阅读git实现的源码。总而言之，git官方文档的book中有如下描述：Git 分支 - 分支的新建与合并如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。以这句话为标准即可，具体看git的合并结果就行。"
  },
  
  {
    "title": "原码、反码、补码范围及特殊情况",
    "url": "/posts/%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81%E8%8C%83%E5%9B%B4%E5%8F%8A%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5/",
    "categories": "学习, 杂知识",
    "tags": "",
    "date": "2021-08-24 15:40:00 +0800",
    





    "snippet": "这篇简单的笔记是考研复习期间写的。尽管考不上了，这篇笔记还是有点价值，记录了几个特殊情况和一些个性化的理解。网上资料较为零散，这里把它们集中说了一下，不过格式比较随意，一些推导方式并不正确但是能帮助理解记忆。一个字节：原码：-127~+127        $-\\frac{127}{128}$~$\\frac{127}{128}$        $-(1-2^{-7})$~$1-2^{-7}$        方便记忆  -0.127~+0.127反码：-127~+127        $-\\frac{127}{128}$~$\\frac{127}{128}$        $-(1-2^{-7})$~$1-2^{-7}$        方便记忆  -0.127~+0.127补码：-128~+127        $-1.0$~$\\frac{127}{128}$        $-1.0$~$1-2^{-7}$        方便记忆  -0.128~+0.127原码反码区分±0，±0.0$[+0]_补=[-0]_补=0,000\\ 0000$$[+0.0]_补=[-0.0]_补=0.000\\ 0000$$[-128]_补=1,000\\ 0000$$[-1.0]_补=1.000\\ 0000$      $[+0]_补 \\ \\&amp;amp;\\  [-0]_补$    $[+0]_原=0,000\\ 0000$    $[+0]_补=0,000\\ 0000$    $[-0]_原=1,000\\ 0000$    $[-0]_反=1,111\\ 1111$    $[-0]_补=10,000\\ 0000 \\xlongequal{溢出丢弃}0,000\\ 0000$    $[+0]_补=[-0]_补=0,000\\ 0000$        $[+0.0]_补 \\ \\&amp;amp;\\ [-0.0]_补$    $[+0.0]_原=0.000\\ 0000$    $[+0.0]_补=0.000\\ 0000$    $[-0.0]_原=1.000\\ 0000$    $[-0.0]_反=1.111\\ 1111$    $[-0.0]_补=10.000\\ 0000 \\xlongequal{溢出丢弃}0.000\\ 0000$    $[+0.0]_补=[-0.0]_补=0.000\\ 0000$        $[-128]_补$    $[-128]_{伪原}=1,1000\\ 0000$    $[-128]_{伪反}=1,0111\\ 1111$    $[-128]_补=1,1000\\ 0000 \\xlongequal{溢出丢弃}1,000\\ 0000$        $[-1.0]_补$    $-1.0\\rightarrow-0.128$    $[-1.0]_{伪原}=1.1000\\ 0000$    $[-1.0]_{伪反}=1.0111\\ 1111$    $[-1.0]_补=1.1000\\ 0000 \\xlongequal{溢出丢弃}1.000\\ 0000$  "
  },
  
  {
    "title": "手动搭建Web服务器环境",
    "url": "/posts/%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BAWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83/",
    "categories": "学习, 杂知识",
    "tags": "",
    "date": "2020-07-25 16:30:00 +0800",
    





    "snippet": "看网上的教程大都是使用PHPStudy等集成包一键搭建的Web环境，使用集成包搭建是能省不少事，但是也少看见了很多东西，这样就不能自己安排，不喜欢这种感觉。我这里是在VM虚拟机的Win7下进行的，其它Windows系统大同小异，其实在Windows Server之类的系统上搭建应该更好。  本文采用Apache+PHP+MySQL进行配置，版本如下：  Apache 2.4.43  PHP 7.4.8 Thread Safe  MySQL 8.0.21  配置期间若出现“缺少VC环境”或“缺少.NET Framework”，自行百度，微软官网安装Apache配置首先下载安装包https://www.apachelounge.com/download/，是一个压缩包。然后创建一个文件夹放置Web服务环境资源，我这里是D:\\Server随后解压到Server文件夹下，这里解压后文件夹的名字叫做Apache24附一张全部搭建完后的Server文件夹的图，其中的PHP，MySQL，www文件夹会在后面创建。开始配置用记事本打开D:\\Server\\Apache24\\conf\\httpd.conf，这是Apache的配置文件。修改以下条目，可按Ctrl+F查找ServerRoot（Apache的根目录）：d:/Server/Apache24，这里更改SRVROOT变量即可Define SRVROOT &quot;c:/Apache24&quot;ServerRoot &quot;${SRVROOT}&quot;改为Define SRVROOT &quot;d:/Server/Apache24&quot;ServerRoot &quot;${SRVROOT}&quot;ServerName（主机名）：localhost:80，去掉#才能让设置生效# If your host doesn&#39;t have a registered DNS name, enter its IP address here.##ServerName www.example.com:80改为# If your host doesn&#39;t have a registered DNS name, enter its IP address here.#ServerName localhost:80DocumentRoot（Apache默认的网页目录）：d:/Server/www原先默认的网页目录是d:\\Server\\Apache24\\htdocs，我这里更改了，新建了d:\\Server\\www文件夹以存放网页，所以要更改DocumentRoot把d:\\Server\\Apache24\\htdocs下的index.html复制到d:\\Server\\www下，以备后续测试# DocumentRoot: The directory out of which you will serve your# documents. By default, all requests are taken from this directory, but# symbolic links and aliases may be used to point to other locations.#DocumentRoot &quot;${SRVROOT}/htdocs&quot;&amp;lt;Directory &quot;${SRVROOT}/htdocs&quot;&amp;gt;改为# DocumentRoot: The directory out of which you will serve your# documents. By default, all requests are taken from this directory, but# symbolic links and aliases may be used to point to other locations.#DocumentRoot &quot;d:/Server/www&quot;&amp;lt;Directory &quot;d:/Server/www&quot;&amp;gt;DirectoryIndex（Apache默认的入口网页）：这里没做更改，就用的默认的index.html没做更改&amp;lt;IfModule dir_module&amp;gt;    DirectoryIndex index.html&amp;lt;/IfModule&amp;gt;如果要更改，可以改为&amp;lt;IfModule dir_module&amp;gt; DirectoryIndex index.php index.html index.htm&amp;lt;/IfModule&amp;gt;index.php index.html index.htm三个文件是有优先关系的，例：若同时有index.php index.html，则默认访问index.php若只有index.html，则默认访问index.htmlScriptAlias（没研究过，反正是个路径）：这里没做更改之前设置ServerRoot的时候，更改过SRVROOT变量为d:/Server/Apache24，而cgi-bin是Apache24下的一个文件夹，这里只要符合cgi-bin的路径即可。我已经符合，故不修改。没做更改ScriptAlias /cgi-bin/ &quot;${SRVROOT}/cgi-bin/&quot;往下几行还有这个，也没改&amp;lt;Directory &quot;${SRVROOT}/cgi-bin&quot;&amp;gt;    AllowOverride None    Options None    Require all granted&amp;lt;/Directory&amp;gt;接下来双击运行D:\\Server\\Apache24\\bin\\httpd.exe，出现了一个没有任何输出的黑窗体，且不会闪退。这其实意味着打开了Apache服务器，不要关闭黑窗体，下面测试：在虚拟机中打开Google Chrome，地址栏输入localhost，可以访问到如下页面在物理机的浏览器中输入虚拟机IP地址也可访问到相同页面（cmd里ipconfig命令可查询IP）  若是没在虚拟机里安装，全部安在物理机也一样，打开浏览器输入localhost，可以访问到上述页面出现It works!说明应该没什么大问题了，关闭黑窗体，接下来把httpd.exe装到Windows服务里。打开cmd，进入httpd.exe所在目录，输入httpd -k install安装服务。  若想删除服务，可以以管理员身份运行cmd用sc delete Apache2.4命令删除安装成功后，在桌面的“计算机”上右键–管理–服务和应用程序–服务，可以查看所有服务，其中就有Apache2.4服务。在该服务上右键-属性，有一个启动类型选项，默认是自动（开机自启），由于只是学习使用，所以我改成了手动，以后可以在该服务上右键-启动来自行控制它。方便起见，我将D:\\Server\\Apache24\\bin下的ApacheMonitor添加到了开始菜单中，这是一个操控Apache服务的图形化界面，打开后在电脑右下角的小图标里找到它，右键-open，界面如下：PHP配置下载安装包https://windows.php.net/download#php-7.4下载Thread Safe版本，否则后期可能缺少php7apache2_4.dll将zip压缩包解压为D:\\Server\\PHP在D:\\Server\\PHP下有这样两个文件：php.ini-development和php.ini-production两个都是PHP的配置文件，https://www.php.net/manual/zh/migration53.ini.phpphp.ini-development包含在开发环境中推荐使用的设置php.ini-production包含在生产环境中推荐使用的设置这里使用php.ini-production，复制更名为php.ini放在同一目录下，以记事本打开开始配置extension_dir（PHP扩展包目录）：; On windows:;extension_dir = &quot;ext&quot;改为; On windows:extension_dir = &quot;ext&quot;  对于低版本的 PHP，这里 extension_dir 要写绝对路径，例如：  extension_dir = &quot;D:\\Development\\PHP_5.6.0\\ext&quot;。  可以通过 phpinfo 验证下文中开启的扩展是否成功开启，从而确定 extension_dir 是否生效。date.timezone（设置时区）：;date.timezone =改为date.timezone = PRCdefault_charset（设置编码）：没有更改，就用默认的UTF-8default_charset = &quot;UTF-8&quot;开启扩展：网上搜了几个常用的扩展，去掉分号开启，功能可查官方文档php_curl.dll                https://www.php.net/manual/zh/book.curl.phpphp_gd2.dll                https://www.php.net/manual/zh/book.image.phpphp_fileinfo.dll          https://www.php.net/manual/zh/book.fileinfo.phpphp_mbstring.dll      https://www.php.net/manual/zh/book.mbstring.phpphp_pdo_mysql.dll   https://www.php.net/manual/zh/ref.pdo-mysql.phpphp_mysqli.dll           https://www.php.net/manual/zh/book.mysqli.php;extension=curl;extension=gd2;extension=fileinfo;extension=mbstring;extension=pdo_mysql;extension=mysqli改为extension=curlextension=gd2extension=fileinfoextension=mbstringextension=pdo_mysqlextension=mysqli为Apache服务添加PHP支持：在此前的httpd.conf文件的最下面添加如下代码：# php7 supportLoadModule php7_module &quot;D:/Server/PHP/php7apache2_4.dll&quot;AddType application/x-httpd-php .php .html .htm# configure the path to php.iniPHPIniDir &quot;D:/Server/PHP&quot;在D:\\Server\\www下新建index.txt文件，输入如下代码&amp;lt;?php    phpinfo();?&amp;gt;更改扩展名为.php，重启先前的Apache服务用浏览器访问localhost/index.php，可得PHP详细信息页面至此就基本没有大问题了下面配置PHP环境变量，这是为了方便在cmd里直接使用PHP，也可以不配置计算机右键-属性-高级系统设置-环境变量，新建系统变量再打开Path系统变量，在后面加上%PHP_HOME%随后在cmd中测试，输入php -version，会显示版本信息，说明配置成功MySQL配置直接下载的离线安装包https://dev.mysql.com/downloads/installer/，跟着下一步下一步，感觉没啥特殊的配置新建MySQL文件夹，D:\\Server\\MySQL选择custom自定义安装，根据需要选择相应组件，我选择装了MySQL Server 8.0；MySQL Shell 8.0；MySQL Notifier 1.1；MySQL Workbench 8.0 CE；Connector ODBC 8.0；Connector C++ 8.0；Connector J 8.0；Connector NET 8.0；MySQL Documentation 8.0；后面就一直“下一步”，除了让你设置密码的时候要设置一下  MySQL卸载可能有点麻烦，这里不赘述，最好一遍成功，下面是遇到的一些坑：      安装组件时，右下角有个Advanced Options选项，很容易忽略，里面可以设置自定义安装路径，且每个组件都要单独设置一遍，不清楚的可以看这个https://blog.csdn.net/qq_40764966/article/details/96702490    安装前确保磁盘空间足够，因为我是在虚拟机里安装，一开始又错装到了C盘，碰巧C盘剩余1G不到，所以提示Fail了  正常安装完后，在计算机右键-管理-服务中可以看到名为MySQL80的服务，可以选择设为手动启动另外，MySQLNotifier就是一个跟ApacheMonitor差不多的东西，也可以通过它开启服务下面测试：在D:\\Server\\www下新建testmysql.txt文件，写上如下代码：&amp;lt;?php    $conn=mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root密码&quot;);    if($conn)        echo &quot;连接success&quot;;    else        echo &quot;连接fail&quot;;?&amp;gt;将txt文件另存为UTF-8编码的文件（要与PHP设置的默认编码一致，否则中文会乱码）更改扩展名为.php，启动Apache服务和MySQL服务，浏览器localhost/testmysql.php访问可得测试成功，至此环境就搭建完了下面配置MySQL环境变量，这是为了方便在cmd里直接使用MySQL，也可以不配置新建系统变量MYSQL_HOME在Path中添加%MYSQL_HOME%\\MySQL Server 8.0\\bin开启MySQL服务，在cmd中输入mysql -h localhost -u root -p，输入密码，若能成功登录，说明配置成功"
  }
  
]

