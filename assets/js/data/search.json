[
  
  {
    "title": "Jekyll Chirpy theme + Github搭建个人博客",
    "url": "/posts/Jekyll-Chirpy-theme-+-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/",
    "categories": "学习, 杂知识",
    "tags": "Jekyll",
    "date": "2022-02-05 14:43:00 +0800",
    





    "snippet": "本地写了不少markdown笔记，一直想自己建一个网站。最初的想法是完完全全自己写一个个人网站，全部自定义，不仅可以有技术笔记栏目还可以有其它记录感想，发表观点，发布工具的栏目。然而时间并不总是能自定义，总有些更优先的事项排在前面，加之自己技术水平还没成长到这个程度，于是退而求其次，选择已有框架搭建一个个人博客，先用之，毕竟都要毕业了，连个像样的博客都没有，实在说不过去。我并未放弃建站的想法，说不定以后就有了。安装博客生成器由于kali环境齐全，所以直接在kali下安装本地博客# 安装jekyllsudo gem install jekyll# 安装chirpy主题git clone git@github.com:cotes2020/jekyll-theme-chirpy.git# 在jekyll-theme-chirpy目录下安装依赖# 不需要sudo，命令会在需要时自动调用sudobundle installjekyll-theme-chirpy文件夹就是一个博客生成器，接下来生成本地初始博客。生成初始博客生成博客# 在jekyll-theme-chirpy目录下生成博客，站点取名为lcatmiao.github.io，这里我取的名与后面要创建的# 远程库的名字一致，其实也可以不一致。# jekyll serve命令自动生成名为_site的站点。-d指定生成路径，同时可以重命名站点文件夹名字。sudo jekyll serve -d lcatmiao.github.io# 然后Ctrl + C关闭服务可以看到已经生成了初始博客lcatmiao.github.io# 再次执行jekyll serve命令，这次我们看一下初始博客的样子再关闭服务。# 下面的命令会再一次生成lcatmiao.github.io文件夹，覆盖现有的，反正我们没做什么更改，覆盖就覆盖，无# 妨。# 默认情况下，只有本机才能访问jekyll服务，同一局域网下的其它主机访问不了。加上--host 0.0.0.0后同一局# 域网下的其它主机就可以访问服务了。这里我的kali是虚拟机，与本机之间是NAT模式。执行下面的命令后，可以# 在本机的浏览器中访问kali的网页。sudo jekyll serve -d lcatmiao.github.io --host 0.0.0.0本机浏览器中输入虚拟机IP，端口号4000，可以浏览到初始博客的样子。关闭服务。创建远程库关于github不多赘述。登录github，创建空仓库，为公开库，名字必须为username.github.io，username为github的用户名。推送初始博客# 进入本地lcatmiao.github.io目录# 初始化本地库sudo git init# 添加暂存区sudo git add .# 提交本地库sudo git commit -m &quot;Initialize the blog&quot; .# 添加远程库sudo git remote add lcatmiao.github.io 库链接# 详细查看远程库sudo git remote -v# 推送远程库sudo git push lcatmiao.github.io master刷新远程库，可以看见初始博客已经被推送上来，访问username.github.io就能访问到自己的初始博客页面。修改配置改_config.yml在jekyll-theme-chirpy目录下修改_config.yml。该文件中的注释描述很清楚，自己看着改。配合 jekyll serve 命令在本地查看修改后页面的效果。改faviconfavicon路径：jekyll-theme-chirpy/assets/img/favicons/准备好图片，然后在https://realfavicongenerator.net/生成，下载后解压，在解压后的文件夹中删除browserconfig.xml和site.webmanifest，然后将剩下的东西复制到jekyll-theme-chirpy/assets/img/favicons/删除最近更新栏最近更新栏似乎没有正常工作，查了很多资料也测试了很久，不知道问题出哪了，我决定删除它。在jekyll-theme-chirpy/_layouts/page.html中  &amp;lt;!-- pannel --&amp;gt;  &amp;lt;div id=&quot;panel-wrapper&quot; class=&quot;col-xl-3 pl-2 text-muted&quot;&amp;gt;    &amp;lt;div class=&quot;access&quot;&amp;gt;      {% include update-list.html %}      {% include trending-tags.html %}    &amp;lt;/div&amp;gt;    {% for _include in layout.pannel_includes %}      {% assign _include_path = _include | append: &#39;.html&#39; %}      {% include {{ _include_path }} %}    {% endfor %}  &amp;lt;/div&amp;gt;删除{% include update-list.html %}推送远程库# 在lcatmiao.github.io目录下sudo git add .sudo git commit -m &quot;Personalize some configs&quot; .sudo git push lcatmiao.github.io master访问username.github.io查看页面。放上内容放入自己的文章jekyll-theme-chirpy/_posts就是我们放置md文件的位置。该目录下已有一些文章，这些是博客主题自带的教程，我们不删除，将它们重命名，在每一个文件名前加一个 # ，这样既可以保留这些文件，又可以避免在博客中呈现它们。下面就可以把我们自己的md文件放进去，md文件可以加上一个 yaml头 ，以启用更多功能。关于 yaml头，直接打开这几个主题自带的md文件看看怎么写就行。放入自己的md后，按照主题自带md文件的命名格式命名。# 重新生成博客站点，打开服务# 在jekyll-theme-chirpy下sudo jekyll serve -d lcatmiao.github.io --host 0.0.0.0本地浏览新生成的页面。推送远程库# 在lcatmiao.github.io下sudo git add .sudo git commit .# commit msgAdd git如何合并分支.mdRename the theme&#39;s own md files so that I can keep them and avoid presenting them inthe blog. Besides, add my own md file, git如何合并分支.md.# 推送远程库sudo git push lcatmiao.github.io masterwindows备份因为博客生成器和博客站点都放在虚拟机kali中，而虚拟机经常要回滚，所以我将整个jekyll-theme-chirpy目录在本机windows中备份一份。附jekyll命令# 打开服务，只有本机能够访问网站# 会生成_site目录# 自动监测变化jekyll serve# 指定生成路径和目录名jekyll serve -d ~/myblog# 局域网内其它主机可访问网站jekyll serve --host 0.0.0.0# 指定端口jekyll serve --port 4001# 后台运行# 不能监测变化jekyll serve --detach"
  },
  
  {
    "title": "关于域名的各种名词叫法",
    "url": "/posts/%E5%85%B3%E4%BA%8E%E5%9F%9F%E5%90%8D%E7%9A%84%E5%90%84%E7%A7%8D%E5%90%8D%E8%AF%8D%E5%8F%AB%E6%B3%95/",
    "categories": "学习, 杂知识",
    "tags": "",
    "date": "2022-01-29 17:31:10 +0800",
    





    "snippet": "关于域名有一些名词，比如域名、顶级域名、二级域名、三级域名、子域名、主机名等。自己总是搞不清这些名词具体指代什么，因为网上的资料总是有各种差别，同一个名词在不同的资料里有不同的解释，属实是迷惑。在查阅了很多资料后，决定做一个总结，尽可能涵盖各种说法，做一个自己理解的标准，以期在遇到这些说法时心里有底。资料基本概念 (aliyun.com)Domain name - WikipediaWhat’s in a Domain Name? All About Domain Levels - Hover Blog下面贴两段我认为有帮助的描述阿里云产品文档基本概念 (aliyun.com)互联网名称与数字地址分配机构（ICANN）负责管理和协调国际互联网络域名系统。根据ICANN的定义，一个完整的域名至少有两个部分，各部分之间用“.”来分隔，最后一个“.”的右边部分称为顶级域名，也称为一级域名；最后一个“.”的左边部分称为二级域名；二级域名的左边部分称为三级域名，以此类推，每一级的域名控制它下一级域名的分配。下图以www.example.com.cn为例，为您介绍域名的级别。注册域名过程中，可自定义的内容在域名后缀的左侧部分。根据注册局规则，可供用户选择的后缀，可能是顶级域名（如“.cn”），也可能是二级域名（如“.com.cn/.net.cn/.org.cn”）。域名解析设置是针对已经完成注册的域名或已注册域名的左侧部分（即域名后缀左侧的左侧）进行解析设置。 所以在解析场景下，对用户解析内容设置的到底是第几个左侧的解释会存在困难。因此，解析场景里，用户注册的完整域名被定义为“一级域名”（不是顶级域名），完整域名的左侧第一个（即一级域名的子域名）是二级域名，以此类推。以注册一个后缀为“.org.cn”、完整域名为“sample.org.cn”的域名为例，对各定义进行如下说明。  域名后缀：“.org.cn”为注册局提供的可注册的域名后缀。  一级域名：“sample.org.cn”为用户注册的完整域名，即解析场景下的一级域名。  二级域名：“abc.sample.org.cn”为“sample.org.cn”的子域名，即解析场景下的二级域名。维基百科Domain name - Wikipedia在Purpose的第一段有：Individual Internet host computers use domain names as host identifiers, also called hostnames. The term hostname is also used for the leaf labels in the domain name system, usually without further subordinate domain name space. Hostnames appear as a component in Uniform Resource Locators (URLs) for Internet resources such as websites (e.g., en.wikipedia.org).在Second-level and lower level domains的第三段有：Second-level (or lower-level, depending on the established parent hierarchy) domain names are often created based on the name of a company (e.g., bbc.co.uk), product or service (e.g. hotmail.com). Below these levels, the next domain name component has been used to designate a particular host server. Therefore, ftp.example.com might be an FTP server, www.example.com would be a World Wide Web server, and mail.example.com could be an email server, each intended to perform only the implied function.总结https://www.example.com.cn/detail/index.html?id=6以上面这个链接为例，https是协议 ，/detail/index.html是路径，id=6是参数。www.example.com.cn这一整个是域名，也是主机名；cn是顶级域名（一级域名）；com是二级域名，也可以说com.cn是二级域名；example是三级域名，也可以说example.com.cn是三级域名；www是四级域名，也可以说www.example.com.cn是四级域名。com是cn的子域名，example是com的子域名，example是com.cn的子域名，www是example.com.cn的子域名，www.example.com.cn是example.com.cn的子域名，这里说法比较随意，子域名是一个相对概念，想象一下树结构就行。example.com.cn是花钱买的部分，是用户注册的部分，买来以后可以设置子域名，比如www。www是自定义的名字，是服务名，可用于指明服务器提供的服务，例如www、ftp、mail；还可以叫它主机名，不过这个叫法与上面提到的“整个域名也是主机名”是两回事。本例中，www也是四级域名。我们平时看到的域名大都以com、cn、org单个结尾，类似下面这样：www.baidu.comwww.360.cnwww.kali.org但也有以com.cn、net.cn、org.cn两个结尾的，如：yz.chsi.com.cnwww.yto.net.cnwww.cnvd.org.cn本例www.example.com.cn便是以com.cn两个结尾的。com.cn、net.cn、org.cn这种看作二级域名，而不是作为整体看作顶级域名（一级域名）。域名后缀可以是顶级域名（一级域名），也可以是二级域名，前三个例子中，com、cn、org是域名后缀，后三个例子中，com.cn、net.cn、org.cn是域名后缀。本例www.example.com.cn中com.cn是域名后缀。关于一级域名、二级域名等还有另一种说法。以www.example.com.cn为例。将用户注册的完整域名叫做一级域名（不能叫顶级域名），随后逐级下降。example.com.cn是一级域名；www是二级域名，也可以说www.example.com.cn是二级域名。"
  },
  
  {
    "title": "git如何合并分支",
    "url": "/posts/git%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/",
    "categories": "学习, git",
    "tags": "git",
    "date": "2022-01-26 13:49:37 +0800",
    





    "snippet": "复制了官网文档中对git合并过程的描述，提取了有必要记录的部分；自己测试了一些关于合并冲突的例子，做一个简要总结。  参考资料：Git 分支 - 分支的新建与合并合并过程快进(fast-forward)现在要将hotfix分支合并到master分支。$ git checkout master$ git merge hotfixUpdating f42c576..3a0874cFast-forward index.html | 2 ++ 1 file changed, 2 insertions(+)合并后如下图：当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。随后可以删除hotfix分支。$ git branch -d hotfix三方合并现在要将iss53分支合并到master分支。$ git checkout masterSwitched to branch &#39;master&#39;$ git merge iss53Merge made by the &#39;recursive&#39; strategy.index.html |    1 +1 file changed, 1 insertion(+)合并后如下图：在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的公共祖先（C2），做一个简单的三方合并。Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。随后可以删除iss53分支。$ git branch -d iss53合并冲突如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们，即会产生合并冲突。  fast-forward 一定不会产生合并冲突。  三方合并可能产生合并冲突。合并冲突的发生有点玄学，不必过于纠结，按照第一段话理解即可。具体会不会发生冲突，老老实实听git的就行，它说冲突那就是冲突了。附上一些实测例子：  git版本：git version 2.34.1.windows.1例一直接fast-forward例二PS E:\\2.学习\\test&amp;gt; git merge hotfixAuto-merging merge.txtMerge made by the &#39;ort&#39; strategy. merge.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)我的理解：master对第一行做了修改，但hotfix没有对第一行做修改，无冲突；两分支都没有对第二行做修改，无冲突；master没有对第三行做修改，但hotfix对第三行做了修改，无冲突。最后合并成功，没有冲突。例三PS E:\\2.学习\\test&amp;gt; git merge hotfixAuto-merging merge.txtCONFLICT (content): Merge conflict in merge.txtAutomatic merge failed; fix conflicts and then commit the result.&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEADqwe222qwe=======qweqwe444&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; hotfixqwe我的理解：这个居然会发生冲突，我是没有想到的。原本应该像例二一样理解，第一行只有master改了，第二行只有hotfix改了，第三行两个分支都没改，应该不会出现冲突。然而却出现了冲突，说明冲突的判定没有想象得那么简单，与git的具体实现有关。这里贴出了git插入的冲突标记。按我的理解，根据冲突标记，git认为两个分支对merge.txt的红框处做了不同修改，产生了冲突；蓝框处两者都没有修改，无冲突；所以最终发生了合并冲突。例四PS E:\\2.学习\\test&amp;gt; git merge hotfixAuto-merging merge.txtCONFLICT (content): Merge conflict in merge.txtAutomatic merge failed; fix conflicts and then commit the result.qwe&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEADqwe222qwe=======qweqwe444&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; hotfix同例三。例五PS E:\\2.学习\\test&amp;gt; git merge hotfixAuto-merging merge.txtCONFLICT (content): Merge conflict in merge.txtAutomatic merge failed; fix conflicts and then commit the result.&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEADqwe666=======qwe444&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; hotfixqwe333qwe555我的理解：这个好理解。两个分支对第二行、第三行做了相同的修改，没有冲突；两个分支分别对第一行做了不同的修改，有冲突；最终发生合并冲突。例六PS E:\\2.学习\\test&amp;gt; git merge hotfixAuto-merging merge.txtCONFLICT (content): Merge conflict in merge.txtAutomatic merge failed; fix conflicts and then commit the result.qwe444qwe333&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEADqwe=======qwe555&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; hotfix我的理解：我迷惑了。。。按照之前的理解，两分支对第一行、第二行做了相同的修改，不冲突；master分支没有对第三行做出修改，hotfix分支对第三行做了修改，不冲突；最终应该不冲突才是。假如将这里master分支对第三行的修改看成是“不变的修改”，那么确实可以说两个分支对第三行做了不同的修改，进而发生冲突。但是这样的说法在例二中就站不住脚，按照这个“不变的修改”的假设，例二应该发生冲突才是。想想也是，这个想法是我凭空想象出来的，多半不可能。总结关于合并冲突的判定没有搞懂，不过我认为继续纠结这个问题没有更多的意义了，除非阅读git实现的源码。总而言之，git官方文档的book中有如下描述：Git 分支 - 分支的新建与合并如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。以这句话为标准即可，具体看git的合并结果就行。"
  }
  
]

