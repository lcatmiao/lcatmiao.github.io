[
  
  {
    "title": "Linux环境配置加载分析",
    "url": "/posts/Linux%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E5%88%86%E6%9E%90/",
    "categories": "Tech, Linux",
    "tags": "shell, bash",
    "date": "2025-12-04 16:42:00 +0800",
    





    "snippet": "本文以 OS: Debian, Shell: bash 为环境写成，其它环境如 OS: RedHat; Shell: sh, zsh 可能与本文结论有所出入。Shell环境配置加载分析在研究shell环境配置文件加载流程前，需要先搞明白 Interactive Shell、Login Shell 的概念。Interactive Shell定义man 说明如下：bash [options] [command_string | file]An interactive shell is one started without non-option arguments (unless -s is specified) and without the -c option, whose standard input and error are both connected to terminals (as determined by isatty(3)), or one started with the -i option.以下条件满足任意一条，即为 Interactive Shell：  启动时，既没有指定非选项参数（除非指定 -s）也没有指定 -c 选项，且标准输入和错误输出都与终端相连。  启动时，指定了 -i 选项。换言之：  没有 -c，没有 -s，没有非选项参数，且标准输入和错误输出都与终端相连，为 Interactive Shell。  没有 -c，有 -s，且标准输入和错误输出都与终端相连，为 Interactive Shell。  有 -i 选项，为 Interactive Shell。感性认识：你敲命令，shell给你回显结果，像这样与人交互的shell就是 Interactive Shell。判定man 说明如下：PS1 is set and $- includes i if bash is interactive, allowing a shell script or a startup file to test this state.以下条件满足任意一条，即为 Interactive Shell：  $PS1 不为空。  $- 中包含字母 i。比如：ssh 远程登录后，其 shell 是 Interactive Shell：orangepi@opidebz3server:~$ echo $PS1\\[\\e]0;\\u@\\h: \\w\\a\\]${debian_chroot:+($debian_chroot)}\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$orangepi@opidebz3server:~$ echo $-himBHs摘自 /etc/bash.bashrc 和 ~/.bashrc 中的判定写法：# /etc/bash.bashrc# If not running interactively, don&#39;t do anything[ -z &quot;$PS1&quot; ] &amp;amp;&amp;amp; return# ~/.bashrc# If not running interactively, don&#39;t do anythingcase $- in    *i*) ;;      *) return;;esacLogin Shell定义man 说明如下：A login shell is one whose first character of argument zero is a -, or one started with the --login option.以下条件满足任意一条，即为 Login Shell：  $0 的首字符是 -。  启动时，指定了 --login(-l) 选项。感性认识：输入密码登录后启动的shell就是 Login Shell。判定判定方法与定义相同。需要注意的是，实测中发现，指定了 --login(-l) 选项的shell，其 $0 的首字符并不是 -。这意味着上述两个条件分别是 Login Shell 的充分不必要条件。若是 Login Shell，$0 的首字符并不总是 -。另外，已然登录系统后，在尝试 bash -c &quot;echo $0&quot; 时，输出竟然是 -bash，但这显然是一个 Non-Interactive Non-Login Shell。综上，依据定义来判定 Login Shell 并不十分可靠。DeepSeek给出了一个号称可靠的检测方法：shopt -q login_shell &amp;amp;&amp;amp; echo &quot;1&quot; || echo &quot;0&quot;，实测中暂未发现问题，也许能够作为 Login Shell 的充要条件。比如：ssh远程登录后，其shell是 Login Shell：orangepi@opidebz3server:~$ echo $0-bashorangepi@opidebz3server:~$ shopt -q login_shell &amp;amp;&amp;amp; echo &quot;1&quot; || echo &quot;0&quot;1启动一个指定了 --login 参数的subshell，按照定义，其shell是 Login Shell：orangepi@opidebz3server:~/Me/Misc$ bash --loginorangepi@opidebz3server:~/Me/Misc$ echo $0bashorangepi@opidebz3server:~$ shopt -q login_shell &amp;amp;&amp;amp; echo &quot;1&quot; || echo &quot;0&quot;1登录系统后，使用 bash -c 执行命令，其shell是 Non-Login Shell：orangepi@opidebz3server:~$ bash -c &quot;echo $0&quot;-bashorangepi@opidebz3server:~$ bash -c &#39;shopt -q login_shell &amp;amp;&amp;amp; echo &quot;1&quot; || echo &quot;0&quot;&#39;0Shell类型举例（有些参数、配置是可以调的，以下只是一般情况。）  source ~/.bashrc 相当于在当前shell中一行行执行了指定的文件，根本不会启动新shell。  启动一个没有GUI的系统，在控制台登录后进入的shell，是 Interactive Login Shell。  ssh命令行远程登录后启动的shell是 Interactive Login Shell。  su - user 启动的shell是 Interactive Login Shell。  在shell中手敲bash打开的subshell是 Interactive Non-Login Shell。  在具备GUI的系统中，登录后进入桌面，手动打开终端，此时启动的shell一般是 Interacive Non-Login Shell。这是因为桌面进程本身可能在一个 Login Shell 中启动，登录后进入桌面再启动的shell是其后代进程，一般不会再是 Login Shell。  su user 启动的shell是 Interacive Non-Login Shell。  登录后，桌面进程可能是在一个由程序启动的shell中启动，我推测这个由程序启动并登录的shell是 Non-Interactive Login Shell。  像 bash --login test.sh 这样启动的shell，它不与人交互，又指定了 --login，显然是 Non-Interactive Login Shell。  像 bash test.sh 或 ./test.sh 这样启动的shell，它不与人交互，执行脚本的时候显然已经登录了系统，所以是 Non-Interactive Non-Login Shell。  无论crontab执行的是系统级还是用户级定时任务，它都不需要登录，其执行shell脚本时启动的shell都是 Non-Interactive Non-Login Shell。  由程序内部启动的shell，如果没有指定特殊参数，多数情况下都是 Non-Interactive Non-Login Shell。启动文件加载分析加载流程# Interactive Login Shell/etc/profile  └/etc/bash.bashrc  └/etc/profile.d/*.sh~/.profile  └~/.bashrc~/.bash_logout/etc/bash.bash_logout# Interactive Non-Login Shell/etc/bash.bashrc~/.bashrc# Non-Interactive Login Shell/etc/profile  └/etc/profile.d/*.sh~/.profile  └~/.bashrc(do nothing and return)~/.bash_logout/etc/bash.bash_logout# Non-Interactive Non-Login Shell$BASH_ENV-&amp;gt; └ 表示调用关系。这些调用关系并不绝对，不同环境可能会有不同情况，应以实际脚本内容为准，不过通常是上述情况。-&amp;gt; 在有些Linux中（非Debian），/etc/bash.bashrc 可能叫做 /etc/bashrc，/etc/bash.bash_logout 可能叫做 /etc/bash_logout。-&amp;gt; 笔者没有在实验环境中新建 ~/.bash_profile、~/.bash_login 文件，只有默认存在的 ~/.profile 文件。若上述文件存在，应该会按照 ~/.bash_profile &amp;gt; ~/.bash_login &amp;gt; ~/.profile 的优先级顺序仅加载存在且可读的第一个文件。这三个文件通常都会 . &quot;$HOME/.bashrc&quot;。-&amp;gt; Interactive Login Shell 退出（比如 Ctrl+D）或 Non-Interactive Login Shell 执行 exit 命令时，bash才会加载 logout 文件，直接关闭bash则不会加载之。-&amp;gt; /etc/profile 摘录如下：if [ &quot;${PS1-}&quot; ]; then  if [ &quot;${BASH-}&quot; ] &amp;amp;&amp;amp; [ &quot;$BASH&quot; != &quot;/bin/sh&quot; ]; then    # The file bash.bashrc already sets the default PS1.    # PS1=&#39;\\h:\\w\\$ &#39;    if [ -f /etc/bash.bashrc ]; then      . /etc/bash.bashrc    fi  else    if [ &quot;$(id -u)&quot; -eq 0 ]; then      PS1=&#39;# &#39;    else      PS1=&#39;$ &#39;    fi  fifiif [ &quot;${PS1-}&quot; ] 是在判断是否是 Interactive Shell，所以 Non-Interactive Login Shell 不会加载 /etc/bash.bashrc。-&amp;gt; ~/.profile 摘录如下：# if running bashif [ -n &quot;$BASH_VERSION&quot; ]; then    # include .bashrc if it exists    if [ -f &quot;$HOME/.bashrc&quot; ]; then        . &quot;$HOME/.bashrc&quot;    fifi~/.bashrc 摘录如下：# If not running interactively, don&#39;t do anythingcase $- in    *i*) ;;    *) return;;esac~/.profile 中加载了 ~/.bashrc，但若不是 Interactive Shell，~/.bashrc 将直接返回，所以 Non-Interactive Login Shell 虽然读了 ~/.bashrc 文件，但其实相当于没有加载它。-&amp;gt; 环境变量 BASH_ENV 的值是一个文件名，Non-Interactive Non-Login Shell 会加载这个文件。我们可以简单记忆：如果是 Login Shell，则会加载 /etc/profile、first of ~/.bash_profile &amp;gt; ~/.bash_login &amp;gt; ~/.profile；如果是 Interactive Shell，则会加载 /etc/bash.bashrc、~/.bashrc。详细文档可参考Bash Reference Manual - 6.2 Bash Startup Files。另附一张国外大佬整理的图片：Bash Initialisation Files特别分析下sudo笔者在各个启动文件和测试文件中都添加了一些测试输出，这些输出被重定向到一个特定文件中以便查看。我们将在bash中手敲一些sudo命令，并结合记录下的测试输出内容进行分析。提前准备启动文件的测试输出：略。logout 文件：略。新建 /root/.profile 文件（一般/root下没有该文件），并调用 /root/.bashrc：echo &quot;$HOME/.profile&quot; &amp;gt;&amp;gt; /home/orangepi/Me/Misc/load_cfg# if running bashif [ -n &quot;$BASH_VERSION&quot; ]; then    # include .bashrc if it exists    if [ -f &quot;$HOME/.bashrc&quot; ]; then        . &quot;$HOME/.bashrc&quot;    fifi设置 BASH_ENV 环境变量：# 直接在bash里手敲export BASH_ENV=/home/orangepi/Me/Misc/test1.shtest1.sh 内容：#!/bin/bashecho &#39;test1.sh&#39; &amp;gt;&amp;gt; /home/orangepi/Me/Misc/load_cfgecho &#39;$BASH_ENV&#39; &amp;gt;&amp;gt; /home/orangepi/Me/Misc/load_cfgtest.sh 内容：#!/bin/bashecho &quot;test.sh&quot; &amp;gt;&amp;gt; /home/orangepi/Me/Misc/load_cfgecho &quot;\\$BASH_ENV: $BASH_ENV&quot; &amp;gt;&amp;gt; /home/orangepi/Me/Misc/load_cfgpstree &amp;gt;&amp;gt; /home/orangepi/Me/Misc/load_cfgecho &quot;&quot; &amp;gt;&amp;gt; /home/orangepi/Me/Misc/load_cfgecho &quot;123&quot; &amp;gt; /dev/nullexit分析sudo&amp;gt; sudo pwd没有测试输出内容。启动 sudo 进程，再启动 pwd 子进程。pwd 是一个二进制可执行程序，不是shell脚本。没有shell被启动，所以没有测试输出内容。&amp;gt; sudo ./test.shtest.sh$BASH_ENV: ...启动 sudo 进程，发现要执行一个shell脚本，于是根据 shebang 启动了一个 bash 子进程，自然是 Non-Interactive Non-Login Shell，于是应该要先加载环境变量 BASH_ENV 指定的文件 test1.sh，然而输出结果是“并没有”且能注意到 BASH_ENV 的值是空的，这是因为 sudo 在默认配置下会重置并保持一个特定的环境，使用 sudo env 可以查看之。bash 启动时发现没有 BASH_ENV，自然就不会加载其指定的文件。&amp;gt; sudo –preserve-env=BASH_ENV pwd没有测试输出内容。--preserve-env=BASH_ENV 使环境变量 BASH_ENV 保留了下来，但 pwd 不是shell脚本，没有shell被启动，所以没有测试输出内容。&amp;gt; sudo –preserve-env=BASH_ENV ./test.shtest1.sh$BASH_ENVtest.sh$BASH_ENV: /home/orangepi/Me/Misc/test1.sh...--preserve-env=BASH_ENV 使环境变量 BASH_ENV 保留了下来，执行 test.sh 时启动了一个 Non-Interactive Non-Login Shell，所以 BASH_ENV 指定的文件 test1.sh 被加载了。&amp;gt; sudo -i/etc/profile/etc/bash.bashrc/etc/profile.d/*.sh/root/.profile/root/.bashrc启动 sudo 进程后还会启动一个shell子进程。-i 表明会启动一个 Login Shell，又因为没有指定要执行的命令，启动的shell将是一个 Interactive Shell，即启动的shell子进程是一个 Interactive Login Shell。测试输出符合预期。若是手动 Ctrl+D 退出shell，在文件存在的情况下，还会依次加载 /root/.bash_logout、/etc/bash.bash_logout。&amp;gt; sudo -i –preserve-env=BASH_ENV pwd/etc/profile/etc/profile.d/*.sh/root/.profile/root/.bashrc(do nothing and return)test1.sh$BASH_ENV居然加载了BASH_ENV，令人意外的结果。首先启动 sudo 进程。其次，由于 -i 且指定了要执行的命令，所以启动一个 Non-Interactive Login Shell。接下来就令人意外了，根据 man sudo 的说法，我猜应该是相当于执行了 bash -c &#39;command&#39;，即启动了一个 Non-Interactive Non-Login Shell 去执行了 pwd。man sudo：-i, --login...If a command is specified, it is passed to the shell as a simple command using the -c option....由于保留了 BASH_ENV，所以 test1.sh 被加载。命令执行完毕后，logout 文件不会被加载，应该是其内部没有正常 exit Login Shell。&amp;gt; sudo -i –preserve-env=BASH_ENV /home/orangepi/Me/Misc/test.sh/etc/profile/etc/profile.d/*.sh/root/.profile/root/.bashrc(do nothing and return)test1.sh$BASH_ENVtest1.sh$BASH_ENVtest.sh$BASH_ENV: /home/orangepi/Me/Misc/test1.sh...  这里 test.sh 使用绝对路径是因为 sudo -i 会将当前路径调整为 /root。首先启动 sudo 进程，然后启动一个 Non-Interactive Login Shell，接着启动一个 Non-Interactive Non-Login Shell(bash -c &#39;command&#39;)，加载了 BASH_ENV，最后根据 shebang 执行 test.sh，于是又启动了一个 Non-Interactive Non-Login Shell，再次加载了 BASH_ENV，最终得到上述测试输出内容。&amp;gt; sudo su/etc/bash.bashrc/root/.bashrc容易理解的结果。启动 sudo 进程后再启动 su 进程，此处未指定用户就默认为是 su root，然后启动了一个 Interactive Non-Login Shell，于是得到上述测试输出内容。&amp;gt; sudo -i –preserve-env=BASH_ENV su -/etc/profile/etc/profile.d/*.sh/root/.profile/root/.bashrc(do nothing and return)test1.sh$BASH_ENV/etc/profile/etc/bash.bashrc/etc/profile.d/*.sh/root/.profile/root/.bashrc笔者故意堆叠buff，造出了这个逆天命令，其测试输出内容也符合预期。  启动 sudo 进程。  因为指定了要执行的命令，又因为 -i，所以启动了一个 Non-Interactive Login Shell。  以 bash -c &#39;su -&#39; 的形式执行命令，将启动一个 Non-Interactive Non-Login Shell，又因为保留了 BASH_ENV，所以将加载 test1.sh。  启动 su 进程。  因为 -，将启动一个 Interacitve Login Shell。  若手动 Ctrl+D 退出shell，在文件存在的情况下，还会加载相应的 logout 文件。&amp;gt; 关于pstree的输出pstree 的输出与我们的理解存在出入，有些shell子进程并没有被显示出来。sudo -i --preserve-env=BASH_ENV /home/orangepi/Me/Misc/test.sh 的 pstree 输出：systemd-+-NetworkManager---2*[{NetworkManager}]...        |-sshd---sshd---sshd---bash---sudo---sudo---test.sh---pstree...DeepSeek的解释是进程替换（execve）机制导致了这一现象，并肯定了笔者上面的理解。重点是DeepSeek肯定了笔者的理解，那应该问题不大🤪，至于什么fork、进程替换云云，不懂，不管了🥱。其它环境配置加载分析/etc/environment该文件是一个系统级的配置文件，主要由PAM认证模块加载。实践中，该文件很少被使用，其对应的用户级配置文件 ~/.pam_environment 基本已被弃用。该文件只支持简单的键值对内容，并非shell脚本，~/.pam_environment 也差不多如此。关于该文件的加载时机，笔者让DeepSeek画了一张图，一目了然。最初的 systemd 就会加载它，而后由 systemd 启动的后续进程将继承环境或者通过PAM认证模块再次加载它，故理论上，所有进程都能吃到该文件环境。  通过这张图还想说明另一件事：本文上面大篇幅讨论的诸如 /etc/profile、~/.profile 等文件只是 shell 的配置文件，其它进程是不会加载它们的，除非其进程内部主动启动了一个shell或者有其它未知的特殊情况。比如，crontab 不是shell，其本身吃不到shell配置文件环境，若其执行shell脚本，则启动的shell将继承其环境，而该shell又是一个 Non-Interactive Non-Login Shell，启动时也不会加载配置文件，这些都将使得该shell在执行时处于一个十分有限的环境，这意味着在使用 crontab 定时执行shell脚本时，于shell配置文件中设置的环境变量将不可见，此时不妨把要使用的环境变量直接写死在脚本里。/etc/rc.d//etc/rc0.d/, /etc/rc1.d/, ... 系列目录属于SysVinit体系的组成部分，目录中是软链接，链接指向 /etc/init.d/ 下真正的脚本。SysVinit是旧的初始化系统，现已被systemd兼容并取代。（DeepSeek）以往没有systemd时，第一个进程是 init，它可能会加载一些自己的配置文件，但不会加载 /etc/environment，然后执行对应运行级别的rc脚本（启动的shell是 Non-Interactive Non-Login Shell），进而启动各项系统服务、守护进程等程序。（DeepSeek）systemd能够兼容SysVinit，它能够为 /etc/init.d/ 下的脚本生成systemd自身的unit文件，进而执行 /etc/init.d/ 下的脚本。（另）service 命令其实是一个shell脚本，如果系统使用SysVinit，它（service nginx start）就相当于 /etc/init.d/nginx start；如果系统使用systemd，它就相当于 systemctl start nginx.service。配置文件角色定位  /etc/profile：shell的系统级配置，Login Shell 的系统级配置入口，其中一般会加载 /etc/bash.bashrc，遍历 /etc/profile.d/。  /etc/bash.bashrc：bash的系统级配置，Interactive Shell 的系统级配置，用于配置所有用户通用的命令提示符样式、命令别名等。  /etc/profile.d/：存放 Login Shell 系统级配置脚本的目录，常用于配置系统级环境变量。  ~/.bash_profile：bash的用户级配置，Login Shell 的用户级配置入口，其中一般会加载 ~/.bashrc。该文件（~/.bash_profile）可用于配置用户级环境变量。该文件是bash专用的配置文件，在需要为bash提供专有配置且其它shell继续使用 ~/.profile 配置时才会派上用场，一般很少使用。bash会按照 ~/.bash_profile &amp;gt; ~/.bash_login &amp;gt; ~/.profile 的优先级顺序仅加载存在且可读的第一个文件。  ~/.bash_login：bash的用户级配置，Login Shell 的用户级配置入口，其中一般会加载 ~/.bashrc。该文件（~/.bash_login）可用于配置用户级环境变量。该文件是bash专用的配置备用文件，功能与 ~/.bash_profile 类似，平时极少使用。bash会按照 ~/.bash_profile &amp;gt; ~/.bash_login &amp;gt; ~/.profile 的优先级顺序仅加载存在且可读的第一个文件。  ~/.profile：shell的用户级配置，Login Shell 的用户级配置入口，其中一般会加载 ~/.bashrc。该文件（~/.profile）常用于配置用户级环境变量。bash会按照 ~/.bash_profile &amp;gt; ~/.bash_login &amp;gt; ~/.profile 的优先级顺序仅加载存在且可读的第一个文件。  ~/.bashrc：bash的用户级配置，Interactive Shell 的用户级配置，用于配置当前用户的命令提示符样式、命令别名等。  ~/.bash_logout：bash的用户级配置，Login Shell 的用户级配置，用于在退出shell（Ctrl+D 或 exit 触发）时执行一些当前用户的操作，如清理操作。  /etc/bash.bash_logout：bash的系统级配置，Login Shell 的系统级配置，用于在退出shell（Ctrl+D 或 exit 触发）时执行一些所有用户通用的操作，如清理操作。一般很少使用该文件。  /etc/environment：PAM认证模块的系统级配置，也被systemd直接加载，只能用于配置环境变量，在现代使用systemd的linux中，理论上所有进程都能吃到该环境，不过一般很少使用。  ~/.pam_environment：PAM认证模块的用户级配置，只能用于配置环境变量，但基本已被弃用。  /etc/rc.d/：/etc/rc0.d/, /etc/rc1.d/, ... 系列目录是SysVinit体系的组成部分，其内存放服务管理脚本的软链接，链接指向 /etc/init.d/。SysVinit现已被systemd兼容并取代。  /etc/init.d/：SysVinit体系的组成部分，其内存放服务管理脚本。"
  },
  
  {
    "title": "你真的搞懂优先级和结合性了吗？",
    "url": "/posts/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7/",
    "categories": "Tech, C",
    "tags": "",
    "date": "2025-11-12 16:44:00 +0800",
    





    "snippet": "颠覆认知我们依据运算符的优先级和结合性来判断一个表达式的运算过程，但我们对于优先级和结合性的理解其实存在着广泛误解。绝大多数教程都是告诉你：  优先级高的运算符先执行。  当出现多个优先级相同的运算符时，依据结合性判断运算符的执行顺序。其实按照上面的说法，将有诸多无法解释的现象，比如：int main(void){    printf(&quot;%c&quot;, &#39;a&#39;) + 1 + 1 + (printf(&quot;%c&quot;, &#39;b&#39;) + printf(&quot;%c&quot;, &#39;c&#39;));    return 0;}括号的优先级最高，所以上面的代码应该先打印 b 或者 c，另外，你也无法回答是 b 先被打印还是 c 先被打印。现在揭晓“答案”，上述代码经过 gcc.exe (x86_64-posix-seh-rev0, Built by MinGW-Builds project) 15.2.0 编译后，在 windows 平台下输出结果是 abc。是不是很疑惑？难道括号没起作用吗？我还能举出一些令你心虚的例子：1 + (2 + 3) + 4 + (5 + 6)请问上面的表达式中是 2 + 3 先执行还是 5 + 6 先执行？你也许会说：括号优先级最高，所以肯定先执行 2 + 3 或者 5 + 6，然后由于这两个括号优先级相同，所以接下来看结合性，又因为括号是左结合性，所以先执行 2 + 3。结合性真的是这样用的吗？请问它的“结合”体现在哪里了？再看一例：1 + 2 + 3 + 4这个表达式由于 + 优先级相同，所以看结合性，又由于是左结合性，所以在这三个连续的 + 中，应该先执行最左边的 +，即先结合最左边的加号及其操作数，变成 (1 + 2) + 3 + 4，再结合第二个加号及其操作数，变成 ((1 + 2) + 3) + 4。相信这个例子与上一例相比，你能够更加感性地体会到“结合”的概念，而在上一例中，你似乎只是单纯地确认了两个子表达式的执行顺序，并没有所谓“结合”的感受。你真的认为上面两例中所谓“结合性的运用”是一样的吗？这对吗？还有众所周知的逻辑运算符：printf(&quot;%c&quot;, &#39;a&#39;) || (printf(&quot;%c&quot;, &#39;b&#39;));这个表达式显然在输出 a 后就结束了，因为 printf() 将返回写入的字符数，前半条件非零为真，直接触发短路，后续不再执行。但我们明明给后半条件加了括号，按照优先级那套说法，b 应该先输出才对。然而这套说法连你自己也不敢相信，因为这违背了短路规则。上面的例子都在说明，日常所见的那套优先级和结合性的说法显然太过简陋，并且导致了不少误解。直接说结论  结合性只作用于连续相邻的同优先级运算符。  优先级和结合性只能确定表达式的执行是怎么分组的，并不能确定子表达式之间或子表达式内部的执行顺序。子表达式之间或内部的执行顺序由编译器自行决定，这在多数情况下并不影响表达式最终的执行结果，而对于那些执行顺序影响执行结果的情况，应当竭力避免之。  sequence point 定义了一些特定的执行顺序。简言之，有些运算符被明确定义了子表达式（操作数）的执行顺序，如 &amp;amp;&amp;amp;、||。理论分析概念定义首先了解一些概念定义。6.1 — Operator precedence and associativity – Learn C++Value computation of operationsThe C++ standard uses the term value computation to mean the execution of operators in an expression to produce a value. The precedence and association rules determine the order in which value computation happens.For example, given the expression 4 + 2 * 3, due to the precedence rules this groups as 4 + (2 * 3). The value computation for (2 * 3) must happen first, so that the value computation for 4 + 6 can be completed.Evaluation of operandsThe C++ standard (mostly) uses the term evaluation to refer to the evaluation of operands (not the evaluation of operators or expressions!). For example, given expression a + b, a will be evaluated to produce some value, and b will be evaluated to produce some value. These values can be then used as operands to operator+ for value computation.ISO/IEC 9899:201x, C11, 5.1.2.3 Program executionAccessing a volatile object, modifying an object, modifying a file, or calling a function that does any of those operations are all side effects,12) which are changes in the state of the execution environment. Evaluation of an expression in general includes both value computations and initiation of side effects. Value computation for an lvalue expression includes determining the identity of the designated object.简单来说，就是表达式的 evaluation 过程包括了 value computations 和 side effects，前者就是常规的值计算过程，后者主要是“写”过程。以表达式 a = (1 + 2) 为例，表达式 (1 + 2) 的 evaluation 过程仅包括了 value computation，即计算 (1 + 2) 得到 3；表达式 a = (1 + 2) 的 evaluation 过程包括了 value computation 和 side effects，前者包含计算表达式 (1 + 2) 的值为 3 的过程和计算表达式 a = 3 的值为 3 的过程，后者是把 3 赋值给 a 的过程。ISO/IEC 9899:201x, C11, 5.1.2.3 Program executionSequenced before is an asymmetric, transitive, pair-wise relation between evaluations executed by a single thread, which induces a partial order among those evaluations. Given any two evaluations A and B, if A is sequenced before B, then the execution of Ashall precede the execution of B. (Conversely, if A is sequenced before B, then B is sequenced after A.) If A is not sequenced before or after B, then A and B are unsequenced. Evaluations A and B are indeterminately sequenced when A is sequenced either before or after B, but it is unspecified which.13) The presence of a sequence point between the evaluation of expressions A and B implies that every value computation and side effect associated with A is sequenced before every value computation and side effect associated with B. (A summary of the sequence points is given in annex C.)这一段主要定义了 sequenced、unsequenced、indeterminately sequenced 以及 sequence point 的概念。      sequenced：有顺序。标准明确规定了子表达式的执行顺序，编译器实现必须遵守。    unsequenced：无顺序。标准没有规定子表达式的执行顺序，编译器可以自由实现，甚至可以并发执行，合并执行子表达式。  indeterminately sequenced：不确定顺序。标准规定子表达式的执行要有顺序，但未规定方向，编译器可以自行选择一个方向实现。论编译器实现自由度，unsequenced &amp;gt; indeterminately sequenced &amp;gt; sequenced。sequence point： 表达式A与B之间存在 sequence point，意味着表达式A的 evaluation(value computation + side effects) 按顺序排列在表达式B的 evaluation 之前。sequence point（DeepSeek）：序列点是程序执行中的一个特定位置，在此位置之前的所有表达式的求值（包括数值计算和副作用）都必须完成，并且不会影响在此之后的所有表达式的求值。提取结论6.1 — Operator precedence and associativity – Learn C++Operator precedenceTo assist with parsing a compound expression, all operators are assigned a level of precedence. Operators with a higher precedence level are grouped with operands first.You can see in the table below that multiplication and division (precedence level 5) have a higher precedence level than addition and subtraction (precedence level 6). Thus, multiplication and division will be grouped with operands before addition and subtraction. In other words, 4 + 2 * 3 will be grouped as 4 + (2 * 3).Operator associativityConsider a compound expression like 7 - 4 - 1. Should this be grouped as (7 - 4) - 1 which evaluates to 2, or 7 - (4 - 1), which evaluates to 4? Since both subtraction operators have the same precedence level, the compiler can not use precedence alone to determine how this should be grouped.If two operators with the same precedence level are adjacent to each other in an expression, the operator’s associativity tells the compiler whether to evaluate the operators (not the operands!) from left to right or from right to left. Subtraction has precedence level 6, and the operators in precedence level 6 have an associativity of left to right. So this expression is grouped from left to right: (7 - 4) - 1.In most cases, the order of evaluation for operands and function arguments is unspecified, meaning they may be evaluated in any order.上述资料的重点可以被总结为三句话：  拥有高优先级的运算符优先与它的操作数一起被分组。  对于拥有相同优先级的相邻两个运算符，由结合性决定哪个运算符先被分组。  操作数（子表达式）和函数参数的求值（执行）顺序没有被明确指定。ISO/IEC 9899:201x, C11, 6.5 ExpressionsThe grouping of operators and operands is indicated by the syntax.85) Except as specified later, side effects and value computations of subexpressions are unsequenced.86)除非特别指定，子表达式的 side effects 和 value computations 是 unsequenced 的。If a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined. If there are multiple allowable orderings of the subexpressions of an expression, the behavior is undefined if such an unsequenced side effect occurs in any of the orderings.84)翻译（DeepSeek）：  如果一个标量对象的副作用，相对于同一个标量对象的另一个副作用，或者相对于使用同一个标量对象的值的值计算是未排序的，那么其行为是未定义的。  如果一个表达式的子表达式存在多种允许的执行顺序，那么在任何一种顺序中，如果出现了这种未排序的副作用，其行为都是未定义的。其实有第一条就差不多了，第二条主要是强调：只要有一种顺序会产生歧义，即使有某些顺序没有歧义，依旧算未定义行为。这段话属实晦涩，仅以例子作简单说明。例1：1 + (a = 2) + 3 + (a = 4) + 5;不知道 (a = 2) 先执行还是 (a = 4) 先执行，它们是 unsequenced 的，两个 side effects（赋值）没有被规定顺序，先执行 (a = 2) 与先执行 (a = 4) 将使变量 a 的最终结果不同。情况符合第一条的描述，是未定义行为。例2：a = 1;1 + (a + 2) + 3 + (a = 4) + 5;不知道 (a + 2) 先执行还是 (a = 4) 先执行，它们是 unsequenced 的，side effects（赋值）与 value computations（加2） 没有被规定顺序，先执行 (a + 2) 与先执行 (a = 4) 将使整个表达式的最终结果不同。情况符合第一条的描述，是未定义行为。先执行 (a = 4) 再执行 (a + 2)，也就是彻底写完了以后读，这看起来没有歧义；若先执行 (a + 2) 再执行 (a = 4)，也就是先读再写，按DeepSeek的意思，这与先前的读产生冲突，导致歧义；两种顺序有一种有歧义，情况符合第二条的描述，是未定义行为。我个人认为把本例往第二条上靠似乎有点牵强，但这不重要，有第一条足够了。例3：i = ++i + 1;分组完毕后是 i = ((++i) + 1)。子表达式内部的执行顺序是 unsequenced 的。(++i) 可以只返回表达式的值，先不给 i 加1，然后该表达式的值与1相加，和赋值给 i，最后再执行 (++i) 的加1，这是一种顺序；(++i) 返回表达式的值并给 i 加1，然后该表达式的值与1相加，和赋值给 i，覆盖掉其当前值，这是一种顺序。情况符合第一条的描述，是未定义行为。Precedence and order of evaluation -Microsoft LearnOnly the sequential-evaluation (,), logical-AND (&amp;amp;&amp;amp;), logical-OR (||), conditional-expression (? :), and function-call operators constitute sequence points, and therefore guarantee a particular order of evaluation for their operands....(The comma operator in a function call is not the same as the sequential-evaluation operator and does not provide any such guarantee.)直译：运算符 ,、&amp;amp;&amp;amp;、||、? :、()（指函数调用，function_name(arguments)）拥有 sequence point，从而保证了特定的求值顺序。（函数参数列表中的逗号与逗号表达式中的逗号运算符是两回事，前者并没有序列点。）ISO/IEC 9899:201x, C11, 6.5.14 Logical OR operatorUnlike the bitwise | operator, the || operator guarantees left-to-right evaluation; if the second operand is evaluated, there is a sequence point between the evaluations of the first and second operands. If the first operand compares unequal to 0, the second operand is not evaluated.其实就是给 || 明确规定了从左到右的执行顺序，并且遵守短路规则。其它特别的运算符诸如 &amp;amp;&amp;amp; 肯定也有明确的序列点定义。ISO/IEC 9899:201x, C11, 6.5.2.2 Function callsEXAMPLE In the function call    (*pf[f1()]) (f2(), f3() + f4())the functions f1, f2, f3, and f4 may be called in any order. All side effects have to be completed before the function pointed to by pf[f1()] is called.There is a sequence point after the evaluations of the function designator and the actual arguments but before the actual call. Every evaluation in the calling function (including other function calls) that is not otherwise specifically sequenced before or after the execution of the body of the called function is indeterminately sequenced with respect to the execution of the called function.94)函数指示符（函数名，也可以是一个函数指针）和函数参数的执行顺序是 unsequenced，所以上例中 f1()、 f2()、f3()、f4() 的调用顺序由编译器自由决定。在“函数指示符和函数参数的求值”和“实际调用的发生”之间，存在一个序列点，即标准明确规定在函数调用前，函数指示符和函数参数的求值必须全部完成，包括所有 value computations 和 side effects。在上例中，一定是 f1()、 f2()、f3()、f4() 都执行完，(*pf[f1()]) 值计算完后才会调用函数 pf[f1()]（即 (*pf[f1()])，* 可加可不加）。调用函数中相对于被调函数体的执行没有被明确指定顺序的 evaluation(including function calls) 相对于被调函数体的执行是 indeterminately sequenced。这条比较抽象，以例说明。例：void func(void){    printf(&quot;%c&quot;, &#39;a&#39;) + 1 + 1 + (printf(&quot;%c&quot;, &#39;b&#39;) + printf(&quot;%c&quot;, &#39;c&#39;));}调用函数就是 func()，被调函数就是任意一个 printf()。上面三个 printf() 的调用是 unsequenced，编译器可以自由选择先调用谁。被调用的 printf() 的函数体一定会完整地执行完才能去调用另一个 printf() 并完整地执行其函数体，不可以并发执行。执行有顺序，方向不确定，即 indeterminately sequenced。C Sequence Points - Microsoft Learn上述链接总结了很多 sequence points，其描述相对于C标准文档通俗很多，故记录链接于此。回到最初的问题问题1：下面表达式的打印结果是什么？printf(&quot;%c&quot;, &#39;a&#39;) + 1 + 1 + (printf(&quot;%c&quot;, &#39;b&#39;) + printf(&quot;%c&quot;, &#39;c&#39;));编译器将保留程序员手动添加的分组（括号），然后根据优先级和结合性进一步分组（分组可以被视作一个整体），结果如下：((printf(&quot;%c&quot;, &#39;a&#39;) + 1) + 1) + (printf(&quot;%c&quot;, &#39;b&#39;) + printf(&quot;%c&quot;, &#39;c&#39;));子表达式的执行顺序是 unsequenced 的，所以上面三个 printf() 被以什么顺序调用都不足为奇，根本就没有固定答案，只是一般来说编译器从左往右执行，所以可能会得到 abc 的结果。本例中表达式的执行顺序未知且会影响打印结果。问题2：`(2 + 3)` 和 `(5 + 6)` 谁先执行？1 + (2 + 3) + 4 + (5 + 6);编译器保留手动添加的分组，然后根据优先级和结合性进一步分组，分组可以被视作一个整体，结果如下：((1 + (2 + 3)) + 4) + (5 + 6);到此为止了，子表达式的执行顺序是 unsequenced 的，所以 (2 + 3) 和 (5 + 6) 谁先执行不知道，但这不影响最终结果。问题3：下面的表达式是怎么执行的？1 + 2 + 3 + 4;编译器根据优先级和结合性分组，结果如下：((1 + 2) + 3) + 4;子表达式的执行顺序是 unsequenced 的，编译器可以先确定 4 的值就是 4，也可以先去求 ((1 + 2) + 3) 的值，顺序未知，不过也不重要，这并不影响最终结果。问题4：下面表达式的打印结果是什么？printf(&quot;%c&quot;, &#39;a&#39;) || (printf(&quot;%c&quot;, &#39;b&#39;));编译器保留手动添加的分组，然后根据优先级进一步分组，函数调用运算符 () 的优先级最高，结果如下：(printf(&quot;%c&quot;, &#39;a&#39;)) || (printf(&quot;%c&quot;, &#39;b&#39;));运算符 || 被规定了明确的执行顺序，并遵守短路规则。所以，一定是先执行左边的表达式，输出 a，然后函数返回 1，触发短路规则，整个表达式直接执行结束，右边的表达式不会再执行。打印结果是明确的，为 a。感想：写到这里，我似乎突然明白为什么国外有些“优先级结合性一览表”中，括号的释义仅仅只有“Function call”而没有“Parentheses”了。“一览表”本身是用来确定分组的，而我们平时添加的括号就是用来手动指定分组的，比起运算符，我更愿意叫它分组标识符，所以它有时不被列进“一览表”也无伤大雅。最后，不要写逆天表达式。"
  },
  
  {
    "title": "五险一金超详细整理",
    "url": "/posts/%E4%BA%94%E9%99%A9%E4%B8%80%E9%87%91%E8%B6%85%E8%AF%A6%E7%BB%86%E6%95%B4%E7%90%86/",
    "categories": "Society",
    "tags": "",
    "date": "2025-08-25 10:53:00 +0800",
    





    "snippet": "前言本文正好成文于 2025 年社保新规前，所以有些内容可能刚整理出来就过时了。文中大多数内容均以浙江省政策为例。政策是会变化的，且各地政策不同，本文仅供学习参考。五险            类别      缴纳      账户                  养老（职工保险）      个人 + 单位      个人 + 统筹              医疗（职工医保）      个人 + 单位      个人 + 统筹              失业      个人 + 单位      统筹              工伤      单位      统筹              生育      单位      统筹        统筹账户也叫统筹基金。  个人账户里的钱都是自己的，至于能从统筹账户中享受多少钱由具体政策决定。养老分类  第一支柱：基本养老保险（主力）          职工基本养老保险      城乡居民基本养老保险1        第二支柱：企业补充养老保险（少数人有）          企业年金      职业年金        第三支柱：个人养老金（自行投资）          个人养老金制度      个人购买的商业养老保险      缴费  职工保险由个人和单位共同缴纳，个人缴纳部分存入个人账户，单位缴纳部分存入统筹账户。  居民保险由个人缴纳和政府补贴，只有个人账户，缴纳和补贴的费用均存入个人账户。  以“灵活就业”形式缴费交的是职工保险。  职工保险按月缴纳，居民保险按年缴纳。  无论是职工保险还是居民保险都需要在退休前缴满至少 15 年（未来可能会提升至 20 年）。  养老保险有一次性补缴机制，但实操仍不建议断缴。  一般只有跨省或跨制度2流动时，临退休前那一阵，才需要转移接续养老保险关系到最终退休地，平时不动它。省内流动，一般不需要转移接续养老保险关系，但若涉及机关事业单位，可能仍需办理。领取      职工基本养老金由基础部分和个人部分构成。基础部分由统筹账户出钱，个人部分由个人账户出钱。        居民基本养老金由基础部分和个人部分构成。基础部分由政府出钱，个人部分由个人账户出钱。无论缴费时选取哪一档，领取时基础部分都是相同的。        居民保险更多是一种保底，待遇完全没法与职工保险相比。        即便个人账户的钱发完了，个人部分的养老金也会继续发，一直发到人去世为止。        个人账户的钱可以继承给家人。        人去世，家人可以领取丧葬费和抚恤金（居民保险只有丧葬费）。丧葬费是两个月的人均月可支配收入，抚恤金是 9-24 个月的人均月可支配收入。        在好几个城市工作过，最后应该在哪里领取基本养老金？          申领养老保险待遇时，若养老保险关系在户籍所在省，无论参保缴费多长时间，均在户籍所在省退休。      申领养老保险待遇时，若养老保险关系不在户籍所在省，且有多段关系均满 10 年，最后一个累计缴费满 10 年且非临时账户3的省份就是退休地、待遇领取地。由此可知，50/40岁前，要规划好自己的最终退休地。      申领养老保险待遇时，若养老保险关系不在户籍所在省，且每个参保地累计缴费均不满 10 年，则在户籍所在省退休，领养老金。        依上述规则，理论上可以卡 bug：户籍地在浙江，50/40 岁前，先在上海交够 10 年，再在浙江交够 10 年，接着可以继续在浙江缴费，临退休前再回上海交几个月（此时不是首次参保，不是临时账户），就可以在上海退休，然后回浙江享受上海高额社平工资加成和浙江本地相对低的物价。（仅供学习理解，实操还是建议提前规划好最终退休地并一直工作到退休。）  计算公式与参数仅以职工保险为例：\\[基本养老金 = 基础部分 + 个人部分\\]\\[基础部分 = 退休前一年度省社平工资 \\times \\frac {1 + 平均缴费指数} {2} \\times 缴费年限 \\times 1\\%\\]\\[个人部分 = \\frac {个人账户余额} {计发月数}\\]      退休前一年度省社平工资为退休前一年全省全口径城镇单位就业人员月平均工资。        平均缴费指数为所有月缴费指数的加权平均值。这里的权就是每个“月缴费指数”对应的缴费月数。月缴费指数为当月缴费基数与当月对应的上年度省社平工资的比值。\\[平均缴费指数 = \\frac {\\Sigma (月缴费指数 \\times 缴费月数)} {累计缴费月数}\\]\\[月缴费指数 = \\frac {月缴费基数} {上年度省社平工资}\\]        公式涉及到的“省社平工资”也可能为“市社平工资”。以后都是用的省级社平工资，国家也在逐步推动统一使用“省级”。目前，除直辖市使用“市级”外，还有一些“计划单列市（如宁波）”使用“市级”；若在政策过渡期退休，也可以依据过渡期政策使用“市级”。但等到 2063 年，可能都是省级了。        在延迟退休的大背景下，年轻人的退休年龄可直接按照 63 岁（男）、55 岁或 58 岁（女）计算。未来可能还会进一步延迟。        缴费年限使用累计缴费月数折算成年。\\[缴费年限 = \\frac {累计缴费月数} {12}\\]        计发月数可网上查表获取。63 岁，计发月数为 117 个月。未来也许会出现为激励延迟退休而减少计发月数的政策。        公式不考虑国家给予的养老金涨幅乘区。        计算精度控制参考下表（以浙江省为上下文，由 deepseek 给出，未求证）：                            计算环节          保留小数          截断方式                                      社平工资          整数输入          -                          平均缴费指数          4 位小数          直接截断                          月缴费指数          4 位小数          四舍五入                          缴费年限          2 位小数          直接截断                          (1 + 平均缴费指数) ÷ 2          4 位小数          直接截断                          个人账户余额          2 位小数          直接截断                          基础部分          2 位小数          直接截断                          个人部分          2 位小数          直接截断                          两数相乘的中间结果          2 位小数          直接截断                    实例解说&amp;gt; 背景张三 2023 年 1 月开始缴费，2063 年 6 月在浙江退休，共缴费 40 年零 6 个月。社会不发展，省社平工资一直都是 10000 元。40 年间张三的月缴费基数一直是 8000 元，但最后 6 个月的月缴费基数为 10000 元。其个人部分的缴费比例为 8%。网络查表可知 63 岁的计发月数为 117 个月。&amp;gt; 计算\\[40年间每个月的月缴费指数 = \\frac {8000} {10000} = 0.8000\\]\\[最后 6 个月中每个月的月缴费指数 = \\frac {10000} {10000} = 1.0000\\]\\[平均缴费指数 = \\frac {0.8000 \\times 40 \\times 12 + 1.0000 \\times 6} {40 \\times 12 + 6} = 0.8024\\]\\[缴费年限 = \\frac {40 \\times 12 + 6} {12} = 40.50\\]\\[基础部分：\\]\\[\\frac {1 + 0.8024} {2} = 0.9012\\]\\[10000 \\times 0.9012 = 9012.00\\]\\[9012.00 \\times 40.50 = 364986.00\\]\\[364986.00 \\times 1\\% = 3649.86 = 基础部分\\]\\[个人账户余额 = 8000 \\times 8\\% \\times 40 \\times 12 + 10000 \\times 8\\% \\times 6 = 312000.00\\]\\[个人部分 = \\frac {312000.00} {117} = 2666.66\\]\\[基本养老金 = 基础部分 + 个人部分 = 3649.86 + 2666.66 = 6316.52\\]可以看到，仅本例中，张三一辈子共交了 312000.00 元养老金。若他能够再活 10 年，活到 2073 年，在不考虑养老金涨幅的情况下，一共可以领到 $6316.52 \\times 12 \\times 10 = 757982.40$ 元养老金，还是划得来的。医疗分类      基本医保          职工医保（城镇职工基本医疗保险）      居民医保（城乡居民基本医疗保险）4        一般来说，在单位上班的，参加职工医保；不在单位上班的，参加居民医保。不在单位上班的成年人，也可以自主选择参加职工医保还是居民医保。如上班族打工仔参加职工医保，学生参加居民医保，自由职业者可自选一种医保参加。        基本医保人员类别          职工医保                  在职职工          灵活就业          医保退休                    居民医保                  少儿医保          大学生医保          城乡一档          城乡二档                    缴费  职工医保由个人和单位共同缴纳，个人缴纳部分存入个人账户，单位缴纳部分存入统筹账户。      居民医保仅由个人缴纳，只有统筹账户，缴纳的费用存入统筹账户。    职工医保按月缴纳，首次参加职工医保，需连续缴费 3-6 个月后才能生效。中途断缴 3 个月内可以补缴，次月恢复医保待遇，断缴超过 3 个月视为重新参保。  居民医保按年缴纳，每年 9-12 月是缴纳窗口期，次年 1 月 1 日生效，全年享受医保待遇。错过缴纳窗口期，补缴后，需等待 90 天才能恢复待遇。新生儿，出生后 90 天内参保，自出生之日起生效；出生后超过 90 天参保，次月生效。  对于职工医保，医保需累计交满 20-25 年，退休后就不用再交钱，直接享受医保报销，终身医保待遇应该就是指这个。如果退休时没有达到年限，可以通过一次性补缴来弥补。居民医保在退休后仍然需要按年缴纳保费，没有终身医保待遇。  医保断缴后，统筹账户立马失效，一般断缴超过 3 个月，之前累计的缴费年限可能会清零（也有的资料说只是连续缴费年限清零，累计缴费年限不会清零，还是要看具体政策），影响终身医保待遇。总之，医保不能断缴，可能造成不必要的麻烦甚至严重后果。  跨省流动时，需要及时转移接续医保关系，如此才能累计缴费年限，合并个账余额。省内流动，参考链接的说法：对于 2022 年 9 月 1 日后在浙江省内跨统筹区参保的人员，实行“自动归集”，无需再办理任何手续；对于2022 年 9 月 1 日前省内跨统筹区参保、有个账结余且未申请办理过医保关系转接的人员，需自主申请。报销  一般情况下都是先用个人账户的钱支付，只有医疗消费（自费+个人账户消费）大于一定数额，才会花到统筹账户的钱。花到统筹账户的钱才算真正意义上的报销，花个人账户的钱其实就是花自己储蓄的钱。医保报销算法不止一套且极其复杂，不深究。  医保个人账户又分为本年账户和历年账户，历年账户的适用范围更广。  基本医保人员类别对应报销比例（从高到低）          医保退休      在职职工、灵活就业      少儿医保、大学生医保、城乡一档      城乡二档        以浙江省为例，参考省内免备案≠省内异地就医不用备案。异地就医省内免备案只是说你可以在省内异地刷码结算，若不办理异地就医备案，报销比例是受影响的。异地就医备案分为异地转诊备案、异地长期居住备案、异地急诊抢救备案，按需办理。特殊机制      职工医保和居民医保都有大病医疗机制，其资金主要来源于统筹账户。其叫法不同，职工医保叫“大额医疗费用补助”，居民医保叫“大病医疗保险”。在一次住院中患者自负金额达到一定标准后，就会被认定为大病，医保会自动启动二次报销。多数情况下，大病医疗机制已被包含在基本医保中；少数情况下，例如灵活就业人员，可能仍需主动缴纳少量费用才能主动开启此机制。    医保有“两病专项保障”机制，针对高血压和糖尿病患者，可提高用药报销比例。此机制需主动办理。  医保有“门诊慢特病报销”机制，针对慢性病和特殊疾病，可提高门诊报销比例。此机制需主动办理。浙江可能会自动帮你打开。  医保有“首诊转诊”机制，在社区签约家庭医生可提高报销比例。  医保有“家庭共济”机制，可将自己的个人账户授权给参加基本医保的家庭成员使用。此机制需主动办理。  医保有“医疗救助”、“失业”、“长期护理（长护险）”机制。失业  没有个人账户，个人缴纳部分和单位缴纳部分都存入统筹账户。  若在多省交过失业保险，则失业保险需要及时转移接续，才能一起累计缴费年限。按一些资料的说法，失业保险的转移接续只能在有就业身份（在当地以就业的身份参保）的时候进行，一旦失业后就无法转移了，这点需要注意。参保人员省内跨区域流动不再需要转移失业保险关系。  领取失业金的条件：          用人单位和本人已按照规定履行缴费义务满一年。      非因本人意愿中断就业。      已依法办理失业登记。      有求职要求，愿意接受职业培训、职业介绍。        失业人员每月领取失业保险金的标准为所在地最低工资的百分之九十。  领取失业金的持续期限：          累计缴费时间不满一年的，不领取失业保险金。      累计缴费时间一年以上不足五年的，每满六个月领取一个月失业保险金，余数满三个月不满六个月的，按照六个月计算。      累计缴费时间五年以上的部分，每满八个月领取一个月失业保险金，余数满四个月不满八个月的，按照八个月计算；但是，领取失业保险金的期限最长不超过二十四个月。        失业人员在领取失业保险金期间，参加职工基本医疗保险，享受基本医疗保险待遇。失业人员应当缴纳的职工基本医疗保险费从失业保险基金中支付。  失业人员再次就业后，缴费时间重新计算。失业人员前次失业领取保险金的期限有剩余的，应当与重新就业、缴费后的领取保险金的期限合并计算。合并后的领取保险金的期限不得超过二十四个月。失业人员在领取失业保险金期间重新就业的，应当在就业之日起十五日内，到原经办机构办理停止领取失业保险金手续。工伤  没有个人缴纳部分，没有个人账户，单位缴纳部分存入统筹账户。  发生工伤后要及时告诉单位，在规定时间内申请工伤认定，一般是 30 天内。生育  没有个人缴纳部分，没有个人账户，单位缴纳部分存入统筹账户。  有些单位会将生育保险和医保交在一起。  构成：生育医疗费用补贴 + 生育津贴。前者产检用，用于报销医院中产生的各种检查费、药费等；后者是休产假期间发的一笔钱。  该险男方也可以有。若女方没工作，男方交了生育保险，则女方可以按规定报销一部分，男方可以享受陪产假津贴。公积金写了好多累坏了，这部分就水一水吧。嗯。缴费  个人和单位各缴纳一半，个人和单位缴纳部分均存入自己的账户，其中的钱全都归自己所有，不区分所谓“个人账户”、“统筹账户”。  公积金断缴会影响公积金贷款资格。一些城市设置贷款申请条件：连续缴纳 6 个月（或 12 个月）且申请时为正常缴纳状态。补缴可能也不计入连续缴存期限。  有些城市要求：提取公积金后必须连续缴存一定时间（比如 6 个月）才能贷款。补缴可能也不计入连续缴存期限。以各地具体政策为准。  跨市流动需要办理公积金转移接续（未找到明确的资料说省内流动不需要转移），从而合并账户余额，至于连续缴费年限如何合并还需具体咨询。公积金转移接续一般要求要先在转入地连续缴存满 6 个月以上且账户状态正常才能申请。一般而言，可以在明确了自己长期发展（定居）的城市以后，或在筹备买房前，办理转移接续，将各城市账户归集到一起。  若在一个城市长期断缴，又不转移，一般来说账户会被封存，不会消失。然而，根据湖南的先例，封存时间 2 年以上的账户也可能面临清理风险，参考关于开展住房公积金睡眠账户清理工作的公告 - 湖南省机关事务管理局。要是真的遇上这种事，应该也会接到通知的。若没有跨市流动——不需要转移，没有单位缴纳，自己也不想缴，但又不想销户提取，暂时不买房，只想留着账户和余额以备未来计划，也许可以这样（仅笔者想象，未实操）：自行正常缴纳，但每隔一阵提取部分（需满足提取条件，比如满足租房提取条件），从而保证账户活跃，又能拿回一部分钱，并按需留一些余额。用途  买房是公积金的主要用途（公积金贷款、对冲月供、公积金年冲等），租房、大病等支出也可使用。  公积金贷款+商业贷款的组合贷形式是一种用于贷款买房的常见形式。  公积金贷款比商业贷款的利率低。  多数情况下，公积金贷款额度与账户余额有关，故公积金提取需谨慎。有些城市不一样，贷款额度可能与“月缴存额”、“缴存年限”有关，需看具体政策。  公积金贷款额度数字长什么样？以浙江嘉兴市为例说明。根据《关于优化住房公积金贷款政策的通知》的政策解读可知：单人缴存最高贷款限额由30万元提高至50万元。根据关于印发《嘉兴市住房公积金缴存管理实施细则》等三个细则的通知可知：不高于按照借款人住房公积金账户存储余额倍数确定的贷款限额，当前倍数为15倍。按上述政策，若借款人账户余额 5 万元，则最多可贷 75 万元，若其为单人贷款，则受 50 万元限制，所以实际最多可贷 50 万元。这只是最大值，实操中是否能达到这个值不太清楚。  公积金贷款可能有次数限制（比如两次），若贷款额度较低（如二三十万），有必要评估此次贷款是否值得。（笔者：两次机会也许可以一次为自己买房，一次为子女买房？）  须还清上一次公积金贷款才能使用第二次。  公积金可用于对冲月供，但每年还有一次机会可用公积金冲抵商贷部分的本金（公积金年冲），从而减少商贷利息。后者相当于用公积金进行提前还款，可能更为划算。自己交五险一金一般来说，养老、医保可以以灵活就业的方式自行缴纳，生育、失业、公积金仅在某些地区可以，工伤不行。一般自行缴纳养老、医保，按需缴纳公积金，其它的视情况而定，不缴也问题不大。灵活就业缴纳社保可以在网上办理，先办理灵活就业参保，等待几分钟的数据同步后，再进行灵活就业缴费（下个月缴纳上个月的社保）。灵活就业内容就填写文字工作者。灵活就业缴纳公积金应该也类似。如确需办理，建议提前办理，实际可能还会遇到没有资格、材料缺失、工作人员没上班等问题，如果缴存地不是户籍地，可能还会遇到麻烦（比如要先办理居住证），这些都需要留时间解决。经电话咨询得知：杭州医保需要累计缴纳 10 年后才能自行缴纳。故就算成功在杭州办理灵活就业参保，也未必能交医保。这种情况想要自己交就只能考虑交在户籍地了，若户籍地就在浙江其它城市，倒也问题不大，然后视情况办理异地就医备案（如异地长期居住备案）。参考资料  【五险一金（保姆教学版）】  不转移社保关系，会影响退休待遇吗？ - 武汉市人民政府门户网站  我已在企业工作两年并缴纳了养老保险，现因工作变动换了一家企业，养老保险该如何办理转移？  国务院办公厅关于转发人力资源社会保障部财政部城镇企业职工基本养老保险关系转移接续暂行办法的通知_国务院文件_中国政府网  在好几个城市工作过，在哪儿领养老金？一起了解→_重庆市人民政府网  【转载学习李永乐老师关于养老保险的知识】  全国人民代表大会常务委员会关于实施渐进式延迟法定退休年龄的决定__中国政府网  【VOL-6 13亿人都有医保，但95%的人根本不了解！】  30分钟、万字长文，一口气了解医保制度 ！  国家医疗保障局 医保动态 职工医保关系转移接续怎么办？——以浙江为例的操作流程  省内免备案≠省内异地就医不用备案  浙江省失业保险条例  浙江省人力资源和社会保障厅等4部门关于进一步统一规范失业保险有关事项的通知  浙江省人力资源和社会保障厅 浙江省财政厅关于印发浙江省失业保险关系转移接续暂行办法的通知  人力资源社会保障部办公厅 财政部办公厅关于畅通失业保险关系跨省转移接续的通知  【打工人看过来！想领更多的失业保险金？先做好失业保险转移】  【用大白话讲清楚2025年怎么正确使用公积金】  【离职/失业后 社保公积金断缴 有什么影响？】  公积金断缴会清零吗？权威解答5大常见误区  公积金取出来还能贷款吗？额度会受影响吗？ - 希财网  【打工人必看！B站最全公积金转移/提取攻略，一次性说清！要不要转移？如何办理转移？】  关于开展住房公积金睡眠账户清理工作的公告 - 湖南省机关事务管理局  关于印发《嘉兴市住房公积金缴存管理实施细则》等三个细则的通知  《关于优化住房公积金贷款政策的通知》的政策解读            2014 年后合并新农保和城居保为城乡居民基本养老保险。 &amp;#8617;              如职工保险与居民保险间的跨越。 &amp;#8617;              临时账户指男性年满 50 周岁、女性年满 40 周岁，且在非户籍地首次参保建立的账户。 &amp;#8617;              2016 年后合并城镇居民医保和新农合为统一的城乡居民基本医疗保险。 &amp;#8617;      "
  },
  
  {
    "title": "死机定位-内存不足死在vmalloc",
    "url": "/posts/%E6%AD%BB%E6%9C%BA%E5%AE%9A%E4%BD%8D-%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E6%AD%BB%E5%9C%A8vmalloc/",
    "categories": "Tech, Linux",
    "tags": "kdb",
    "date": "2025-06-01 20:30:00 +0800",
    





    "snippet": "定位过程死机调用栈如下，推栈结果与 bt 结果大差不差。由一个终端程序一路调用到 vmalloc，最后死在其内部。注意到函数 out_of_memory，这表明可能是系统内存快耗尽了。[0]kdb&amp;gt; btStack traceback for pid 6930xffff880362416740      693        1  1    0   R  0xffff8803624171c0 *vtysh[15792.666500]  ffff88042d6bb818 0000000000000018 ffffffff818604c0 ffff88042d6bb858[15792.755452]  ffffffff8109f38e ffff88042d6bb848 ffffffff817a6588 000000000040adbd[15792.844406]  ffffffff818604c0 ffffffff818607b0 ffff880054d36fa8 ffff88042d6bb868[15792.933360] Call Trace:[15792.962596]  [&amp;lt;ffffffff8109f38e&amp;gt;] ? notifier_call_chain+0x4e/0x80[15793.035508]  [&amp;lt;ffffffff8109f45a&amp;gt;] ? atomic_notifier_call_chain+0x1a/0x20[15793.115702]  [&amp;lt;ffffffff81147eb1&amp;gt;] ? panic+0x101/0x21e[15793.176131]  [&amp;lt;ffffffff8114ddce&amp;gt;] ? out_of_memory+0x46e/0x470[15793.244884]  [&amp;lt;ffffffff81153b96&amp;gt;] ? __alloc_pages_nodemask+0x9b6/0xb30[15793.322995]  [&amp;lt;ffffffff8119376c&amp;gt;] ? alloc_pages_current+0x8c/0x110[15793.396945]  [&amp;lt;ffffffff8118832f&amp;gt;] ? __vmalloc_node_range+0x16f/0x290[15793.472977]  [&amp;lt;ffffffff813af519&amp;gt;] ? n_tty_open+0x19/0xe0[15793.536526]  [&amp;lt;ffffffff811884f4&amp;gt;] ? vmalloc+0x54/0x60[15793.596958]  [&amp;lt;ffffffff813af519&amp;gt;] ? n_tty_open+0x19/0xe0[15793.660508]  [&amp;lt;ffffffff813af519&amp;gt;] ? n_tty_open+0x19/0xe0[15793.724060]  [&amp;lt;ffffffff813b38f2&amp;gt;] ? tty_ldisc_open.isra.2+0x32/0x60[15793.799050]  [&amp;lt;ffffffff813b41c0&amp;gt;] ? tty_ldisc_hangup+0x1d0/0x200[15793.870922]  [&amp;lt;ffffffff813ab592&amp;gt;] ? __tty_hangup+0x2b2/0x3e0[15793.938634]  [&amp;lt;ffffffff813abe29&amp;gt;] ? disassociate_ctty.part.25+0x49/0x2a0[15794.018825]  [&amp;lt;ffffffff813ac0f9&amp;gt;] ? disassociate_ctty+0x29/0x30[15794.089657]  [&amp;lt;ffffffff81083792&amp;gt;] ? do_exit+0x732/0xa80[15794.152168]  [&amp;lt;ffffffff8108c1cf&amp;gt;] ? recalc_sigpending+0x1f/0x60[15794.222996]  [&amp;lt;ffffffff81083b73&amp;gt;] ? do_group_exit+0x43/0xb0[15794.289668]  [&amp;lt;ffffffff8108f2c8&amp;gt;] ? get_signal+0x278/0x5e0[15794.355300]  [&amp;lt;ffffffff81005358&amp;gt;] ? do_signal+0x28/0x6d0[15794.418853]  [&amp;lt;ffffffff8100217d&amp;gt;] ? exit_to_usermode_loop+0x6d/0xa0[15794.493841]  [&amp;lt;ffffffff81002a88&amp;gt;] ? syscall_return_slowpath+0x48/0x60[15794.570915]  [&amp;lt;ffffffff8152dc6b&amp;gt;] ? int_ret_from_sys_call+0x25/0x8f     r15 = 0x0000000000000000      r14 = 0xffffffff8cff41c0      r13 = 0x0000000000000000      r12 = 0xffffffff8188ad00       bp = 0xffff88042d6bb818       bx = 0x00000000fffffffe      r11 = 0x000000000000ae76      r10 = 0x0000000000039940       r9 = 0xffffffff818bbd00       r8 = 0x0000000000000000       ax = 0x0000000000000001       cx = 0x00000000ffffffff       dx = 0xffffffff8cff41c0       si = 0x0000000000000000       di = 0xffffffff818bbd00  orig_ax = 0xffffffffffffffff       ip = 0xffffffff8130fad9       cs = 0x0000000000000010    flags = 0x0000000000000046       sp = 0xffff88042d6bb800       ss = 0x0000000000000018 &amp;amp;regs = 0xffff88042d6bb768[0]kdb&amp;gt; 0xffffffff8130fad90xffffffff8130fad9 = 0xffffffff8130fad9 (kdb_panic+0x29)[0]kdb&amp;gt; md 0xffff88042d6bb818 10xffff88042d6bb818 ffff88042d6bb858 ffffffff8109f38e   X.k-............[0]kdb&amp;gt; ffffffff8109f38effffffff8109f38e = 0xffffffff8109f38e (notifier_call_chain+0x4e)[0]kdb&amp;gt; md ffff88042d6bb858 10xffff88042d6bb858 ffff88042d6bb868 ffffffff8109f45a   h.k-....Z.......[0]kdb&amp;gt; ffffffff8109f45affffffff8109f45a = 0xffffffff8109f45a (atomic_notifier_call_chain+0x1a)[0]kdb&amp;gt; md ffff88042d6bb868 10xffff88042d6bb868 ffff88042d6bb8e8 ffffffff81147eb1   ..k-.....~......[0]kdb&amp;gt; ffffffff81147eb1ffffffff81147eb1 = 0xffffffff81147eb1 (panic+0x101)[0]kdb&amp;gt; md ffff88042d6bb8e8 10xffff88042d6bb8e8 ffff88042d6bb948 ffffffff8114ddce   H.k-............[0]kdb&amp;gt; ffffffff8114ddceffffffff8114ddce = 0xffffffff8114ddce (out_of_memory+0x46e)[0]kdb&amp;gt; md ffff88042d6bb948 10xffff88042d6bb948 ffff88042d6bba98 ffffffff81153b96   ..k-.....;......[0]kdb&amp;gt; ffffffff81153b96ffffffff81153b96 = 0xffffffff81153b96 (__alloc_pages_nodemask+0x9b6)[0]kdb&amp;gt; md ffff88042d6bba98 10xffff88042d6bba98 ffff88042d6bbae8 ffffffff8119376c   ..k-....l7......[0]kdb&amp;gt; ffffffff8119376cffffffff8119376c = 0xffffffff8119376c (alloc_pages_current+0x8c)[0]kdb&amp;gt; md ffff88042d6bbae8 10xffff88042d6bbae8 ffff88042d6bbb68 ffffffff8118832f   h.k-..../.......[0]kdb&amp;gt; ffffffff8118832fffffffff8118832f = 0xffffffff8118832f (__vmalloc_node_range+0x16f)[0]kdb&amp;gt; md ffff88042d6bbb68 10xffff88042d6bbb68 ffff88042d6bbb98 ffffffff811884f4   ..k-............[0]kdb&amp;gt; ffffffff811884f4ffffffff811884f4 = 0xffffffff811884f4 (vmalloc+0x54)[0]kdb&amp;gt; md ffff88042d6bbb98 10xffff88042d6bbb98 ffff88042d6bbbb8 ffffffff813af519   ..k-......:.....[0]kdb&amp;gt; ffffffff813af519ffffffff813af519 = 0xffffffff813af519 (n_tty_open+0x19)[0]kdb&amp;gt; md ffff88042d6bbbb8 10xffff88042d6bbbb8 ffff88042d6bbbd8 ffffffff813b38f2   ..k-.....8;.....[0]kdb&amp;gt; ffffffff813b38f2ffffffff813b38f2 = 0xffffffff813b38f2 (tty_ldisc_open.isra.2+0x32)[0]kdb&amp;gt; md ffff88042d6bbbd8 10xffff88042d6bbbd8 ffff88042d6bbc08 ffffffff813b41c0   ..k-.....A;.....[0]kdb&amp;gt; ffffffff813b41c0ffffffff813b41c0 = 0xffffffff813b41c0 (tty_ldisc_hangup+0x1d0)[0]kdb&amp;gt; 0xffffffff813b41c0 10xffffffff813b41c0 = 0xffffffff813b41c0 (tty_ldisc_hangup+0x1d0)[0]kdb&amp;gt; ffffffff813b41c0ffffffff813b41c0 = 0xffffffff813b41c0 (tty_ldisc_hangup+0x1d0)[0]kdb&amp;gt; md ffff88042d6bbc08 10xffff88042d6bbc08 ffff88042d6bbc68 ffffffff813ab592   h.k-......:.....[0]kdb&amp;gt; ffffffff813ab592ffffffff813ab592 = 0xffffffff813ab592 (__tty_hangup+0x2b2)[0]kdb&amp;gt; md ffff88042d6bbc68 10xffff88042d6bbc68 ffff88042d6bbc98 ffffffff813abe29   ..k-....).:.....[0]kdb&amp;gt; ffffffff813abe29ffffffff813abe29 = 0xffffffff813abe29 (disassociate_ctty.part.25+0x49)[0]kdb&amp;gt; md ffff88042d6bbc98 10xffff88042d6bbc98 ffff88042d6bbca8 ffffffff813ac0f9   ..k-......:.....[0]kdb&amp;gt; ffffffff813ac0f9 1ffffffff813ac0f9 = 0xffffffff813ac0f9 (disassociate_ctty+0x29)[0]kdb&amp;gt; md ffff88042d6bbca8 10xffff88042d6bbca8 ffff88042d6bbd28 ffffffff81083792   (.k-.....7......[0]kdb&amp;gt; ffffffff81083792ffffffff81083792 = 0xffffffff81083792 (do_exit+0x732)summary 显示 16G 的内存现在只剩下 144M 了。Slab 占用 12317492KB，且不可回收的 Slab 内存 SUnreclaim 高达 12296600KB。[0]kdb&amp;gt; summarysysname    Linuxrelease    4.19.90-20version    machine    x86_64nodename   ...domainname (none)ccversion  gcc version 5.4.0 (...)uptime     04:04load avg   61.45 60.49 60.02MemTotal:       16955124 kBMemFree:          144116 kBMemAvailable:      70124 kBBuffers:              40 kBCached:           613968 kBSwapCached:            0 kBActive:           354580 kBInactive:          96308 kBActive(anon):     354560 kBInactive(anon):    96284 kBActive(file):         20 kBInactive(file):       24 kBUnevictable:      517652 kBMlocked:               0 kBSwapTotal:             0 kBSwapFree:              0 kBDirty:                 0 kBWriteback:             0 kBAnonPages:        354656 kBMapped:            41356 kBShmem:             96312 kBSlab:           12317492 kBSReclaimable:      20892 kBSUnreclaim:     12296600 kBKernelStack:        3216 kBPageTables:        86772 kBNFS_Unstable:          0 kBBounce:                0 kBWritebackTmp:          0 kBCommitLimit:     8477560 kBCommitted_AS:    2659584 kBVmallocTotal:   34359738367 kBVmallocUsed:           0 kBVmallocChunk:          0 kBAnonHugePages:     38912 kBCmaTotal:              0 kBCmaFree:               0 kBHugePages_Total:     0HugePages_Free:      0HugePages_Rsvd:      0HugePages_Surp:      0Hugepagesize:     2048 kB部分 dmesg 信息如下：[0]kdb&amp;gt; dmesg 200&amp;lt;3&amp;gt;[14579.560239] Out of memory: Kill process 16281 (...) score 0 or sacrifice child&amp;lt;3&amp;gt;[14579.560251] Killed process 16281 (...) total-vm:439208kB, anon-rss:2048kB, file-rss:1656kB&amp;lt;2&amp;gt;[14579.562861] %%--.../SYSTEM/2/SYSLOG(l): Failed to allocate memory for [vtysh] process,please check system memory usage details.&amp;lt;3&amp;gt;[14579.562866] Out of memory: Kill process 7712 (...) score 0 or sacrifice child&amp;lt;3&amp;gt;[14579.562877] Killed process 7712 (...) total-vm:437196kB, anon-rss:2188kB, file-rss:1352kB&amp;lt;2&amp;gt;[14579.563225] %%--.../SYSTEM/2/SYSLOG(l): Failed to allocate memory for [vtysh] process,please check system memory usage details.&amp;lt;3&amp;gt;[14579.563228] Out of memory: Kill process 7731 (...) score 0 or sacrifice child&amp;lt;3&amp;gt;[14579.563237] Killed process 7731 (...) total-vm:439208kB, anon-rss:2040kB, file-rss:1424kB&amp;lt;2&amp;gt;[14579.564227] %%--.../SYSTEM/2/SYSLOG(l): Failed to allocate memory for [vtysh] process,please check system memory usage details.&amp;lt;3&amp;gt;[14579.564234] Out of memory: Kill process 5351 (...) score 0 or sacrifice child&amp;lt;3&amp;gt;[14579.564241] Killed process 5351 (...) total-vm:439780kB, anon-rss:2044kB, file-rss:1412kB...&amp;lt;4&amp;gt;[14579.571210] vtysh invoked oom-killer: gfp_mask=0x24002c2, order=0, oom_score_adj=0...&amp;lt;0&amp;gt;[14579.571720] Kernel panic - not syncing: Out of memory and no killable processes...可以看到 oom-killer 被唤醒，系统已经开始杀进程了。Kernel panic - not syncing: Out of memory and no killable processes... 表明 oom-killer 已经没有可杀的进程了，内核无法通过 oom-killer 释放足够内存，最终系统崩溃。经过确认，设备的并发连接数较高，slab 的确是要占用很多内存，基本可以排除是内存泄漏，所以定位结论就是内存不足导致死机，修改方案就是针对特定功能做内存限制。一个疑问为什么内存不足会导致死机？换言之，为什么死机会死在 vmalloc 内部？如果内存不足，vmalloc 不应该返回 NULL 吗？我原先以为应该是 vmalloc 内存分配失败返回 NULL，结果上层调用者没有对返回值进行判断，直接使用了 NULL 所指的异常内存，最终导致空指针错误，但事实并非如此。难道 vmalloc 不健壮？可是这怎么可能呢？为此，我询问了 DeepSeek，虽然不知道它的回答是否正确，但它成功说服了我，我觉得应该是对的。原因分析：  vmalloc 在内存不足时确实会返回 NULL，但前提是它能正常执行到分配失败的处理路径。  当系统处于严重内存耗尽状态时，vmalloc 自身的执行过程可能需要分配内存（如创建页表、管理数据结构），而这些内部操作也可能因内存不足而失败。当触发 OOM killer 但释放内存失败时，内核会直接调用 panic() 终止系统，而不是返回到 vmalloc。结论：vmalloc 内部调用的页分配器触发 OOM killer，但 OOM killer 无法释放足够内存，最终内核主动 panic()。  📌 关键启示：当内存耗尽到一定程度时，内核自身的基本操作（如分配管理数据结构）都可能失败，此时系统会直接崩溃，而不是优雅地返回错误。这类似于“氧气面罩失效时，飞行员无法操作降落系统”的级联失效场景。DeepSeek 的说法确实有道理，此前我并不知道 vmalloc 内部本身也有内存分配的操作，这样就说得通了：vmalloc 内部的执行也需要内存，若是连这点内存都不够了，就只能绝望地主动触发死机了。定位结论高并发环境下，设备维持了大量会话，占用了大量内存，以致内存接近耗尽。此时，一个与终端相关的进程发起了系统调用，期间申请了内存。然而，由于内存消耗较为极端，以致一些基本的内存管理操作都难以为继，内核 vmalloc 函数为了继续执行下去就唤起了 OOM killer 杀进程，但即便杀死了一些进程，内存也依然不够用，vmalloc 函数还没来得及返回 NULL 就不得不主动触发了死机。尽管上面的理解不一定正确，但该结论应该是八九不离十吧，应该，嗯。"
  },
  
  {
    "title": "用户态源码反汇编定位方法记录",
    "url": "/posts/%E7%94%A8%E6%88%B7%E6%80%81%E6%BA%90%E7%A0%81%E5%8F%8D%E6%B1%87%E7%BC%96%E5%AE%9A%E4%BD%8D%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/",
    "categories": "Tech, C",
    "tags": "gdb",
    "date": "2025-05-24 21:55:00 +0800",
    





    "snippet": "前言问题背景就是进程崩溃，产生了 core 文件。其实这次定位非常简单，bt, disassemble 就能直接看出来了。既然简单，就利用这次机会尝试了一下源码反汇编的定位方法。此前在别人的帮助下，运用该方法定位过内核态的问题，但都事发紧急，事后没能复盘，留下了遗憾。尽管存在差异，还是决定在用户态“模拟”一下。定位过程Program terminated with signal SIGSEGV, Segmentation fault.#0  0x00007fcff9ad157a in check ()   from ....so(gdb) bt#0  0x00007fcff9ad157a in check ()   from ....so#1  0x00007fcff9ad27c1 in func ()   from ....so#2  0x00007fcff9ad3483 in func ()   from ....so#3  0x00007fcff9ad6696 in func ()   from ....so#4  0x00007fcff9ad9a40 in func ()   from ....so#5  0x00007fd018fa50d6 in func () from ....so#6  0x000000000041dbe9 in func ()#7  0x00000000004178bd in func ()#8  0x00007fd018fc39fd in func () from ....so#9  0x000000000040b56c in main ()死在 check() 中。(gdb) disassemble checkDump of assembler code for function check:   0x00007fcff9ad1408 &amp;lt;+0&amp;gt;:     push   %r15   0x00007fcff9ad140a &amp;lt;+2&amp;gt;:     push   %r14   0x00007fcff9ad140c &amp;lt;+4&amp;gt;:     mov    %rdi,%r14...   0x00007fcff9ad156c &amp;lt;+356&amp;gt;:   mov    0x48(%r14),%rax   0x00007fcff9ad1570 &amp;lt;+360&amp;gt;:   or     $0xffffffffffffffff,%rcx   0x00007fcff9ad1574 &amp;lt;+364&amp;gt;:   mov    (%rax,%rbp,1),%rdi   0x00007fcff9ad1578 &amp;lt;+368&amp;gt;:   xor    %eax,%eax=&amp;gt; 0x00007fcff9ad157a &amp;lt;+370&amp;gt;:   repnz scas %es:(%rdi),%al   0x00007fcff9ad157c &amp;lt;+372&amp;gt;:   mov    %rcx,%rax   0x00007fcff9ad157f &amp;lt;+375&amp;gt;:   not    %rax   0x00007fcff9ad1582 &amp;lt;+378&amp;gt;:   dec    %rax   0x00007fcff9ad1585 &amp;lt;+381&amp;gt;:   cmp    $0x200,%rax...找到崩溃指令的偏移量为 +370，其十六进制为 172。接下来准备编译源码。编译前准备：  源码版本须与问题版本一致  给源码编译加上 -g 参数，去掉 STRIP，除此以外的编译参数都不变（与编译问题版本时的参数保持一致）将问题代码所在的文件编译出来，得到对应的 so。随后，在开发环境中反汇编：# -S  Intermix source code with disassembly# -l  Include line numbers and filenames in outputobjdump check.so -S -l &amp;gt; check.c.asm在 check.c.asm 中直接找到 check 函数。其第一条指令的首地址为 2653a。我们将之加上先前在调试环境中得到的崩溃指令的偏移量： 2653a + 172 = 266ac，就得到了开发环境中崩溃指令的偏移量。   2653a:    ....../.../check.c:3498        return ERR_MAX_CFG;    }    for (i = 0 ;i &amp;lt; obj-&amp;gt;sizeList; i++)    {        snprintf(err_str, NAME_LEN,&quot;list[%d].host&quot;, i);   26699:    e8 42 3b ff ff           callq  1a1e0 &amp;lt;snprintf@plt&amp;gt;/.../check.c:3499        if (strlen(obj-&amp;gt;list[i].host) &amp;gt; 512)   2669e:    49 8b 46 48              mov    0x48(%r14),%rax   266a2:    48 83 c9 ff              or     $0xffffffffffffffff,%rcx   266a6:    48 8b 3c 28              mov    (%rax,%rbp,1),%rdi   266aa:    31 c0                    xor    %eax,%eax   266ac:    f2 ae                    repnz scas %es:(%rdi),%al   266ae:    48 89 c8                 mov    %rcx,%rax   266b1:    48 f7 d0                 not    %rax   266b4:    48 ff c8                 dec    %rax   266b7:    48 3d 00 02 00 00        cmp    $0x200,%rax可以看到 266ac 的崩溃指令 repnz scas %es:(%rdi),%al 与调试环境中的崩溃指令是一致的。随即观察附近的源码，就知道问题所在了。1000% 是 strlen() 的问题，多半是 host 为 NULL 了。实测一番，果不其然，直接复现。注意事项在开发环境中重新编译相关源码时，需保证代码版本、编译参数（除 -g, STRIP 外）与问题版本一致，否则反汇编结果将与问题版本所在环境的反汇编结果不一致，在开发环境中就无法精准地找到同样的崩溃指令了，二者汇编都对不上，也就无法定位了。"
  },
  
  {
    "title": "gdb无-g调试实战记录",
    "url": "/posts/gdb%E6%97%A0-g%E8%B0%83%E8%AF%95%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/",
    "categories": "Tech, C",
    "tags": "gdb",
    "date": "2025-04-24 22:00:00 +0800",
    





    "snippet": "问题背景设备外发日志的内容错乱，甚至产生 core 文件。版本是正常编译的发行版本，没有附带 -g 加入的调试信息。我懒得加调试信息也不想加 -g 重新编译，二者在本人的开发环境中都十分麻烦。这种无 -g 调试的场景其实还蛮常见的，这次定位比较顺利，故记录之。定位过程从现象上看是日志内容错位了，但也不能排除是踩内存，出界内容被直接解析也能出现类似的现象。通过看代码，我高度怀疑日志结构体在传参进入函数 output_syslog(log_s *in_buffer) 的时候就已经有问题了。没有 -g 的话，就只能进行有限的调试，通过跟踪地址、强看汇编来定位。gdb 给怀疑的函数 output_syslog() 打断点，命中后，寄存器信息如下：(gdb) b output_syslog Breakpoint 1 at 0x43ed38(gdb) cContinuing.Breakpoint 1, 0x000000000043ed38 in output_syslog ()(gdb) i rx0             0x7f91acf008     547904876552x1             0x0      0x2             0x7ffa1eecd0     549657177296x3             0x7ffa1f0210     549657182736x4             0x2000   8192...设备是 arm 架构，上面的寄存器名称也是一眼 arm。我们现在刚进入函数 output_syslog，还没有做任何其它操作，所以 x0 就是函数第一个参数的值。0x7f91acf008 就是 in_buffer 的值，也就是结构体 log_s 的首地址。这个结构体还挺大的，大概长下面这样：typedef struct {    u8      member;    u8      member;        u8      member;    u8      member;    u8      member;    u8      member;    u8      member;    u8      member;    u8      member[MAX_LEN];    u8      member[MAX_LEN];    u16     member;    u16     member;    u16     member;    u16     member;    u16     member;    u16     member;    u16     member;    u16     member[COUNT];    union {        in_addrv4_s in_addrv4;        in_addrv6_s in_addrv6;    } adrv;    u32     ip_version;    u32     member;    u32     member;    u32     member;    u32     member;    u32     member;    u32     member;    u32     member;    u32     focus_on_this_id;    u32     member;    u32     member;    u32     member;    s8      host[MAX_LEN];    s8      url[MAX_LEN];    ...} log_s;我直接从首地址开始以字符的形式打印了 2000 个字节，如下：(gdb) x/2000bc 0x7f91acf008  0x7f91acf008:   6 &#39;\\006&#39;        1 &#39;\\001&#39;        0 &#39;\\000&#39;        0 &#39;\\000&#39;        2 &#39;\\002&#39;        1 &#39;\\001&#39;   0 &#39;\\000&#39; 2 &#39;\\002&#39;0x7f91acf010:   97 &#39;a&#39;  116 &#39;t&#39; 116 &#39;t&#39; 97 &#39;a&#39;  99 &#39;c&#39;  107 &#39;k&#39; 95 &#39;_&#39;  98 &#39;b&#39;0x7f91acf018:   108 &#39;l&#39; 111 &#39;o&#39; 99 &#39;c&#39;  107 &#39;k&#39; 0 &#39;\\000&#39;        0 &#39;\\000&#39;        0 &#39;\\000&#39;        0 &#39;\\000&#39;0x7f91acf020:   0 &#39;\\000&#39;        0 &#39;\\000&#39;        0 &#39;\\000&#39;        0 &#39;\\000&#39;        0 &#39;\\000&#39;        0 &#39;\\000&#39;   0 &#39;\\000&#39; 0 &#39;\\000&#39;...观察发现，前 8 个 u8 的值都是对的，没啥问题，说明到这里数据都还是对的，没有发生错误偏移的迹象。难道说是后面的数据发生了偏移，亦或是后面的数据越界踩内存了吗？继续往后看。由于结构体中有很多成员，且数组成员还比较大，按顺序一个个找成员的话，实在麻烦，况且由于对齐，结构体成员内存分布还不一定是连续的，所以我直接从后往前找。我挑选了一个需要重点关注的变量，focus_on_this_id，根据实际情况和代码，我知道这个值取低 16 位后应该为 10035，但实际值却为 16，现在需要重点搞清这个错误的原因。注意到这一段：...0x7f91acf670:   0 &#39;\\000&#39;        0 &#39;\\000&#39;        0 &#39;\\000&#39;        1 &#39;\\001&#39;        0 &#39;\\000&#39;        0 &#39;\\000&#39;        0 &#39;\\000&#39;        7 &#39;\\a&#39;0x7f91acf678:   0 &#39;\\000&#39;        0 &#39;\\000&#39;        0 &#39;\\000&#39;        0 &#39;\\000&#39;        16 &#39;\\020&#39;       0 &#39;\\000&#39;        39 &#39;\\&#39;&#39; 51 &#39;3&#39;0x7f91acf680:   82 &#39;R&#39;  0 &#39;\\000&#39;        0 &#39;\\000&#39;        17 &#39;\\021&#39;       48 &#39;0&#39;  0 &#39;\\000&#39;        5 &#39;\\005&#39;        0 &#39;\\000&#39;---Type &amp;lt;return&amp;gt; to continue, or q &amp;lt;return&amp;gt; to quit---0x7f91acf688:   48 &#39;0&#39;  0 &#39;\\000&#39;        5 &#39;\\005&#39;        1 &#39;\\001&#39;        119 &#39;w&#39; 119 &#39;w&#39; 119 &#39;w&#39; 46 &#39;.&#39;0x7f91acf690:   116 &#39;t&#39; 101 &#39;e&#39; 115 &#39;s&#39; 116 &#39;t&#39; 104 &#39;h&#39; 116 &#39;t&#39; 116 &#39;t&#39; 112 &#39;p&#39;0x7f91acf698:   46 &#39;.&#39;  99 &#39;c&#39;  111 &#39;o&#39; 109 &#39;m&#39; 0 &#39;\\000&#39;        0 &#39;\\000&#39;        0 &#39;\\000&#39;        0 &#39;\\000&#39;...第 6 行开始的 www.testhttp.com 一眼就应该是 host 成员的值。观察结构体，focus_on_this_id 附近都是 u32，如果结构体要填充，应该在前面的 adrv 附近就填充完了，也就是说，从 focus_on_this_id 到 host 应当都是连续的。大胆假设数据偏移没有错误，即 www.testhttp.com 就是 host 的值，那么往前再数 4 * 4 个字节，就是 focus_on_this_id 的值，如下：# from low address to high address16 &#39;\\020&#39;    0 &#39;\\000&#39;    39 &#39;\\&#39;&#39;    51 &#39;3&#39;# convert to hex\\x10    \\x00    \\x27    \\x33arm 架构是小端序，所以 focus_on_this_id 的数值为 0x33270010，取低 16 位，其十进制正好为 16，与实际值相同，这说明数据偏移大概率真的没有问题，我们找到的值应该就是变量 focus_on_this_id 的值。进一步，注意到 10035 的十六进制为 0x2733，此刻已经很能说明问题了——高度怀疑是字节序问题。试倒转变量的字节序，数值就为 0x10002733，取低 16 位，即是 10035！分析到这里八九不离十了，直接查代码，好家伙果不其然，就是整个结构都没转字节序。感悟虽说问题是内部测试发现的，我可以加 -g 重新编译，但如果是在前方环境定位，哪来的调试信息？实际上，无 -g 直接上 gdb 调试一样能调，只不过很考验调试者在汇编、指针、内存等底层原理上的功底。临汇编而不惧，寻指针而不乱，观内存而烛微，此谓之高手也。吾辈当以之为目标，不断精进。"
  },
  
  {
    "title": "简析HTTPS",
    "url": "/posts/%E7%AE%80%E6%9E%90HTTPS/",
    "categories": "Tech, Network",
    "tags": "tls",
    "date": "2025-04-15 18:50:00 +0800",
    





    "snippet": "写在前面阅读《图解HTTP》，大致理解了 SSL/TLS 的握手过程和思想原理。然而作为入门书，它没有介绍基于 DH 算法的 TLS 握手过程，也没有介绍证书链相关的知识😡。我 Google 了不少资料，着重啃了几篇文章，结合抓包分析，本想“差不多得了”，却没料到入了大坑，疑问不减反增。一筹莫展之际，AI 技术大火，救我狗命。受此鼓舞，借助 AI 解惑，又打起精神啃读了多个 RFC 片段，遂拨云见日。本文既成，虽得益于天时，然亦可谓一波三折，历尽艰辛。我真牛逼👍。本文主要基于 TLS1.2 研写，知识整理于此👇。先行概念&amp;gt; 密码体制密码学主要有两种体制：  共享密码体制（对称密码体制）  公钥密码体制（非对称密码体制）&amp;gt; 数学难题公钥密码体制主要基于以下数学难题：  大整数分解问题  离散对数问题（DLP）          一般的离散对数问题      椭圆曲线离散对数问题（ECDLP）      一般的说法中，通常将椭圆曲线离散对数问题单独作为一类，与离散对数问题、大整数分解问题一起，并称密码学三大数学难题。椭圆曲线离散对数问题比一般的离散对数问题更加困难，自然就诞生了基于椭圆曲线的密码学，被称作椭圆曲线密码学（ECC）。一些原本基于一般离散对数问题的算法被移植到椭圆曲线上，就有了 ECC 的算法版本，比如 DH 算法的椭圆曲线版本，就叫 ECDH 算法。一些公钥算法与数学难题的对应关系：  RSA - 大整数分解问题  DH、DSA - 一般的离散对数问题  ECDH、ECDHE、ECDSA - 椭圆曲线离散对数问题TLS 握手过程TLS 在握手中主要做了三件事——身份认证、密钥交换和完整性校验。握手主要是为了生成并交换共享密钥，这个过程是使用公钥算法进行的，客户端和服务器都拥有共享密钥后，后续的通信再使用共享密钥算法进行加密。这是安全和性能综合考量的结果。公钥算法安全但性能消耗多，共享密钥算法相对不那么安全但性能消耗少，所以真正的加密通信使用共享密钥加密，而且共享密钥的交换则由公钥算法实现。以下基于 TLS1.2 阐述其握手过程。基于 RSA 算法步骤 1 - 发起连接，协商参数客户端发送 `Client Hello`。客户端生成随机数 Client Random，并发送 Client Hello 报文。该报文中包含 Client Random 随机数以及客户端支持的算法套件等信息，这些信息被传递给服务器用于协商。步骤 2 - 协商参数，发送证书服务器发送 `Server Hello, Certificate, Server Hello Done`。      服务器从 Client Hello 中获得随机数 Client Random。        服务器生成 Server Random，将该随机数包含进 Server Hello 中。服务器依据自身情况，从客户端算法套件中挑选一个自身支持的算法，将其包含进 Server Hello 中。        服务器发送自己的证书。证书中主要包含以下信息：                  服务器的公钥                    服务器的域名                    其它附加信息                    CA 的签名：使用 CA 的私钥对上述证书信息的哈希值加密所得的结果。        signature = ca-private-key((hash(cert-info)))                          服务器发送 Server Hello Done。  如下图，服务器发送报文。如下图，服务器选择了算法 TLS_RSA_WITH_AES_256_CBC_SHA。如下图，服务器发送了自己的证书，该证书被 CA 签名，签名使用的签名算法是 RSA，哈希算法是 SHA256。步骤 3 - 身份认证，密钥交换，生成会话密钥客户端发送 `Client Key Exchange, Change Cipher Spec, Encrypted Handshake Message`。  客户端从 Server Hello 中获得随机数 Server Random。  客户端使用 CA 的证书（一般已预置在浏览器中）验证服务器的证书。使用 CA 证书中包含的公钥解密服务器证书中的签名，得到哈希值，再计算服务器证书信息的哈希值，二者对比，若一致则验证通过。验证通过，证明了服务器证书是由浏览器内置的 CA 证书所代表的 CA 颁发的，即证明了内置 CA 信任服务器；而内置的 CA 是广受社会信任的 CA，已经是信任锚点。就这样，浏览器信任 CA，CA 信任服务器，所以浏览器信任服务器。这一信任链证明了服务器的身份值得信赖，且证书中的公钥的确属于服务器，此即身份认证。  客户端生成 PreMaster Secret，并使用服务器的公钥加密，使用 Client Key Exchange 发送给服务器，此即密钥交换。  客户端使用 Client Random, Server Random, PreMaster Secret 生成会话密钥 Session Key。  Change Cipher Spec 向服务器表明：客户端已经拥有会话密钥，接下来发送的所有数据都会使用会话密钥加密。  客户端计算出一个校验数据，使用会话密钥加密后，作为 Encrypted Handshake Message1 发送给服务器。如下图，客户端发送报文。如下图，在 Client Key Exchange 部分可以看到使用服务器的 RSA 公钥加密发送的 PreMaster Secret。步骤 4 - 密钥交换，生成会话密钥服务器发送 `Change Cipher Spec, Encrypted Handshake Message`。  服务器使用自己的私钥解密得到 PreMaster Secret，此即密钥交换。  服务器使用 Client Random, Server Random, PreMaster Secret 生成会话密钥 Session Key。  服务器使用 Session Key 解密客户端发来的校验数据，并计算报文哈希值与校验数据进行对比。  Change Cipher Spec 向客户端表明：服务器已经拥有会话密钥，接下来发送的所有数据都会使用会话密钥加密。  服务器计算出一个校验数据，使用会话密钥加密后，作为 Encrypted Handshake Message2 发送给客户端。如下图，服务器发送报文。如下图，报文信息长这样。步骤 5 - 完成握手，加密通信双方发送 `Application Data`。  客户端使用 Session Key 解密服务器发来的校验数据，并计算报文哈希值与校验数据进行对比。  TLS 连接建立完成。接下来双方使用 Session Key 加密数据，进行 HTTPS 通信。如下图，发送加密的 HTTP 报文。步骤 6 - 断开连接客户端发送 `Encrypted Alert`。客户端使用 Session Key 加密一个告警信息，发送 Encrypted Alert3 以断开 TLS 连接。后续再关闭 TCP 的连接。基于 ECDHE 算法在 RSA 握手中，PreMaster Secret 由客户端发送给服务器，从而完成密钥交换；而在 DH 算法中，客户端和服务器基于数学原理，根据一些公开的信息直接在各自的本地计算出 PreMaster Secret，连网络传输都给干掉了，所以 DH 算法更加安全。DH 算法简介原理DH 算法是一种密钥交换算法，我们不管数学细节，极简阐述原理：# 客户端和服务器各持有一对 DH 公私钥，使用它们各自的私钥和对端的公钥可以生成一个会话密钥，# 而两端各自生成的会话密钥在数学上被证明是相等的。换言之，只要两端互相交换公钥就可以实现# 无需网络传输的会话密钥交换。client-session-key = dh(client-private-key, server-public-key)server-session-key = dh(server-private-key, client-public-key)session-key = client-session-key = server-session-key分类DH 算法基于离散对数问题而诞生，根据离散对数的计算方式（见数学难题）可以分为：  一般的 DH 算法  ECDH 算法根据 DH 的私钥是否固定，可以分为：  Static DH  Ephemeral DH(DHE)在 Static DH 算法中，服务器每次连接所使用的 DH 私钥是不变的，应该是直接使用的与公钥证书成对的那个私钥，长期使用容易泄露，一旦泄露，黑客就能解密当前和以往每次连接的通信，这样的算法不具备前向安全性；而在 Ephemeral DH 算法中，服务器会为每次连接重新生成一个临时的 DH 私钥，这样就算私钥泄露，也只能解密这一次连接的通信，无法解密以往的通信，所以算法具备前向安全性。ECDHE 握手流程步骤 1 - 发起连接，协商参数客户端发送 `Client Hello`。同 RSA 握手。步骤 2 - 协商参数，发送证书和 ECDH 信息服务器发送 `Server Hello, Certificate, Server Key Exchange, Server Hello Done`。相比 RSA 握手，多了一个 Server Key Exchange，阐述如下。在这步，服务器会选择一种椭圆曲线，生成一对 ECDH 公私钥，并使用 Server Private Key 对 Client Random, Server Random, Curve Info, Server DH Public Key 的组合进行签名，最后将曲线信息、ECDH 公钥、签名都包含进 Server Key Exchange 中。signature = server-private-key(    hash(client-random, server-random, curve-info, server-dh-public-key))此处签名和后续验签的意义在于证明 ECDH 信息的确是由证书中的公钥所代表的服务器发送的。  服务器是协商选择椭圆曲线的。客户端会通过 elliptic_curves 或 supported_groups 扩展字段发送其支持的全部曲线，随后服务器再从中选择一个。随着标准的不断发展，elliptic_curves 已经逐步被 supported_groups 取代。因 TLS 版本的不同，上述说法存在一些细节出入，但大体上没问题。如下图，服务器发送报文。如下图，服务器选择了算法 TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256。这里我们服务器的密钥对是 ECC 密钥对，所以协商选择了 ECDSA 签名算法。如下图，服务器发送了自己的证书，该证书被 CA 签名，签名算法是 ECDSA，哈希算法是 SHA256。这里我们 CA 的密钥对也是 ECC 密钥对，使用的 ECDSA 算法签发的公钥证书。如下图，服务器发送了自己生成的 ECDH 公钥，其采用的 ECC 曲线为 Named Curve: secp256r1 (0x0017)。计算出的数字签名也被发送，由于服务器的私钥是 ECC 的，所以签名算法选择了 ECDSA。步骤 3 - 身份认证，密钥交换，生成会话密钥客户端发送 `Client Key Exchange, Change Cipher Spec, Encrypted Handshake Message`。  客户端从 Server Hello 中获得随机数 Server Random。  客户端使用 CA 的证书（一般已预置在浏览器中）验证服务器的证书，由此证明服务器的身份值得信赖，证书中的公钥的确代表服务器的身份，此即身份认证。  客户端使用证书中的公钥验证 Server Key Exchange 中的签名，由此证明 ECDH 信息的发送者的确是公钥所代表的服务器，此即身份认证。  客户端基于服务器选择的曲线生成一对 ECDH 公私钥。  客户端将生成的 Client DH Public Key 放入 Client Key Exchange 以发送给服务器。  客户端使用 Client DH Private Key, Server DH Public Key 直接在本地计算出 PreMaster Secret，后续服务器也会直接在本地计算出同样的 PreMaster Secret，此即密钥交换。  客户端使用 Client Random, Server Random, PreMaster Secret 生成会话密钥 Session Key。  同 RSA 握手，发送 Change Cipher Spec 和 Encrypted Handshake Message1。如下图，在 Client Key Exchange 部分可以看到发送的 Client DH Public Key。步骤 4 - 密钥交换，生成会话密钥服务器发送 `Change Cipher Spec, Encrypted Handshake Message`。  服务器使用 Client DH Public Key, Server DH Private Key 直接在本地计算出与客户端一致的 PreMaster Secret，此即密钥交换。  服务器使用 Client Random, Server Random, PreMaster Secret 生成会话密钥 Session Key。  服务器使用 Session Key 解密客户端发来的校验数据，并计算报文哈希值与校验数据进行对比。  同 RSA 握手，发送 Change Cipher Spec 和 Encrypted Handshake Message2。步骤 5 - 完成握手，加密通信双方发送 `Application Data`。同 RSA 握手。步骤 6 - 断开连接客户端发送 `Encrypted Alert`。同 RSA 握手。补充说明校验数据 Finished MessageThe Illustrated TLS Connection: Every Byte Explained 较为详细地展示了 ECDHE 握手的流程，其说法如下：The verification data is built from a hash of all handshake messages and verifies the integrity of the handshake process.RFC5246  The Transport Layer Security (TLS) Protocol Version 1.2 的说法如下：# 7.4.9  FinishedThe value handshake_messages includes all handshake messages startingat ClientHello up to, but not including, this Finished message.  Thismay be different from handshake_messages in Section 7.4.8 because itwould include the CertificateVerify message (if sent).  Also, thehandshake_messages for the Finished message sent by the client willbe different from that for the Finished message sent by the server,because the one that is sent second will include the prior one.Note: ChangeCipherSpec messages, alerts, and any other record typesare not handshake messages and are not included in the hashcomputations.  Also, HelloRequest messages are omitted from handshakehashes.据此猜测，本文例子中，参与哈希的报文区间大概是 [Client Hello, Client/Server Finished), Exclude(Change Cipher Spec)。MAC 摘要所有使用 Session Key 加密的数据，其内都包含了一个名为 MAC (Message Authentication Code) 的报文摘要。MAC 有多种实现，比如 HMAC 和 GMAC。HMAC 和 GMAC 的特点（AI）：  HMAC          基于哈希函数（如 SHA256）      适用于通用场景      需要显式地与加密算法（如 AES-CBC）结合使用        GMAC          基于 Galois 域运算      专为 GCM 模式设计，通常与 AES-GCM 结合使用。      提供更高的性能，尤其是在硬件加速的场景中。      具体机制本文不研究，我的理解是数据和 MAC 一起被加密传输，对端解密后，再计算数据的 MAC 与接收到的 MAC 值对比，从而探知数据是否被篡改，此即完整性校验。试计算 Server Key Exchange 中的签名并验签在 ECDHE 握手-步骤 2 中，我们提到签名是对 Client Random, Server Random, Curve Info, Server DH Public Key 的组合进行的。信息收集如下：# client random\\x5b\\x70\\x1c\\x25\\x8a\\xf4\\x56\\x6a\\x81\\xa7\\xee\\xcf\\xa0\\x9f\\xbb\\xcb\\x35\\xfd\\x64\\xae\\xe5\\xb0\\x46\\x03\\xda\\x92\\x4e\\xa0\\x07\\x79\\x35\\x2a# server random\\xcc\\x26\\xf9\\x66\\x00\\x00\\x00\\x00\\x67\\x78\\x0a\\x00\\x00\\x00\\x00\\x00\\x3f\\x00\\x00\\x00\\x3f\\x00\\x00\\x00\\x3f\\x00\\x00\\x00\\x3f\\x00\\x00\\x00# curve info\\x03\\x00\\x17# server dh public key\\x41\\x04\\x39\\x3b\\x76\\x31\\x87\\x80\\xe0\\x0b\\x27\\xd4\\xe7\\xc4\\x95\\x27\\x9c\\x2f\\xeb\\x96\\xa6\\xe8\\xd9\\x87\\x42\\x2e\\xce\\xac\\x84\\xa2\\x68\\xda\\x6f\\x6f\\x08\\x05\\xaa\\xf9\\x5d\\x23\\xa0\\x24\\xd1\\x25\\x30\\x84\\x11\\x55\\xcb\\xe9\\x69\\xeb\\xfb\\xcf\\xa8\\xbd\\xf8\\x96\\x8a\\x0a\\x7e\\xad\\x1c\\xef\\x84\\xa8将这些数据合并在一起：# compose the data togetherecho -n &quot;\\x5b\\x70\\x1c\\x25\\x8a\\xf4\\x56\\x6a\\x81\\xa7\\xee\\xcf\\xa0\\x9f\\xbb\\xcb\\x35\\xfd\\x64\\xae\\xe5\\xb0\\x46\\x03\\xda\\x92\\x4e\\xa0\\x07\\x79\\x35\\x2a\\xcc\\x26\\xf9\\x66\\x00\\x00\\x00\\x00\\x67\\x78\\x0a\\x00\\x00\\x00\\x00\\x00\\x3f\\x00\\x00\\x00\\x3f\\x00\\x00\\x00\\x3f\\x00\\x00\\x00\\x3f\\x00\\x00\\x00\\x03\\x00\\x17\\x41\\x04\\x39\\x3b\\x76\\x31\\x87\\x80\\xe0\\x0b\\x27\\xd4\\xe7\\xc4\\x95\\x27\\x9c\\x2f\\xeb\\x96\\xa6\\xe8\\xd9\\x87\\x42\\x2e\\xce\\xac\\x84\\xa2\\x68\\xda\\x6f\\x6f\\x08\\x05\\xaa\\xf9\\x5d\\x23\\xa0\\x24\\xd1\\x25\\x30\\x84\\x11\\x55\\xcb\\xe9\\x69\\xeb\\xfb\\xcf\\xa8\\xbd\\xf8\\x96\\x8a\\x0a\\x7e\\xad\\x1c\\xef\\x84\\xa8&quot; &amp;gt; data服务器本身的私钥也贴在此处，文件以 \\n 结尾。这是一个基于曲线 prime256v1(secp256r1) 的 ECC 私钥。# server private key-----BEGIN EC PARAMETERS-----BggqhkjOPQMBBw==-----END EC PARAMETERS----------BEGIN EC PRIVATE KEY-----MHcCAQEEIIshQQR4px7Ek+5jRugTnySv5cjqSs1PbDlnmR1SSC4joAoGCCqGSM49AwEHoUQDQgAE4Q+9ZBPkV4b2buqwPLB9EskoGByXTcPuF22znhtFG2R9gVlFyU4S3GyXx3QaFOfLLNdyl/puch+GlZAZZsYKPw==-----END EC PRIVATE KEY-----其十六进制为：# server private key hexxxd -ps server-ecc-key.pem | tr -d &quot;\\n&quot; | sed &#39;s/\\(..\\)/\\\\x\\1/g&#39;\\x2d\\x2d\\x2d\\x2d\\x2d\\x42\\x45\\x47\\x49\\x4e\\x20\\x45\\x43\\x20\\x50\\x41\\x52\\x41\\x4d\\x45\\x54\\x45\\x52\\x53\\x2d\\x2d\\x2d\\x2d\\x2d\\x0a\\x42\\x67\\x67\\x71\\x68\\x6b\\x6a\\x4f\\x50\\x51\\x4d\\x42\\x42\\x77\\x3d\\x3d\\x0a\\x2d\\x2d\\x2d\\x2d\\x2d\\x45\\x4e\\x44\\x20\\x45\\x43\\x20\\x50\\x41\\x52\\x41\\x4d\\x45\\x54\\x45\\x52\\x53\\x2d\\x2d\\x2d\\x2d\\x2d\\x0a\\x2d\\x2d\\x2d\\x2d\\x2d\\x42\\x45\\x47\\x49\\x4e\\x20\\x45\\x43\\x20\\x50\\x52\\x49\\x56\\x41\\x54\\x45\\x20\\x4b\\x45\\x59\\x2d\\x2d\\x2d\\x2d\\x2d\\x0a\\x4d\\x48\\x63\\x43\\x41\\x51\\x45\\x45\\x49\\x49\\x73\\x68\\x51\\x51\\x52\\x34\\x70\\x78\\x37\\x45\\x6b\\x2b\\x35\\x6a\\x52\\x75\\x67\\x54\\x6e\\x79\\x53\\x76\\x35\\x63\\x6a\\x71\\x53\\x73\\x31\\x50\\x62\\x44\\x6c\\x6e\\x6d\\x52\\x31\\x53\\x53\\x43\\x34\\x6a\\x6f\\x41\\x6f\\x47\\x43\\x43\\x71\\x47\\x53\\x4d\\x34\\x39\\x0a\\x41\\x77\\x45\\x48\\x6f\\x55\\x51\\x44\\x51\\x67\\x41\\x45\\x34\\x51\\x2b\\x39\\x5a\\x42\\x50\\x6b\\x56\\x34\\x62\\x32\\x62\\x75\\x71\\x77\\x50\\x4c\\x42\\x39\\x45\\x73\\x6b\\x6f\\x47\\x42\\x79\\x58\\x54\\x63\\x50\\x75\\x46\\x32\\x32\\x7a\\x6e\\x68\\x74\\x46\\x47\\x32\\x52\\x39\\x67\\x56\\x6c\\x46\\x79\\x55\\x34\\x53\\x0a\\x33\\x47\\x79\\x58\\x78\\x33\\x51\\x61\\x46\\x4f\\x66\\x4c\\x4c\\x4e\\x64\\x79\\x6c\\x2f\\x70\\x75\\x63\\x68\\x2b\\x47\\x6c\\x5a\\x41\\x5a\\x5a\\x73\\x59\\x4b\\x50\\x77\\x3d\\x3d\\x0a\\x2d\\x2d\\x2d\\x2d\\x2d\\x45\\x4e\\x44\\x20\\x45\\x43\\x20\\x50\\x52\\x49\\x56\\x41\\x54\\x45\\x20\\x4b\\x45\\x59\\x2d\\x2d\\x2d\\x2d\\x2d\\x0a现在使用私钥对数据签名，openssl 会根据私钥类型自动选择相应的签名算法，对于 ECC 私钥，会默认选择 ECDSA 算法。报文中实际使用的签名算法为 ecdsa_secp256r1_sha256，这里我们使用 -sha256，使哈希算法也保持一致。# sign the data with the server private keyopenssl dgst -sign server-ecc-key.pem -sha256 -out sig data# see the signaturexxd -ps sig# result:3044022020b6c7803f90785be49b6d70744f82bc7a421718da24e39abb743505fe23882b02203b56f27ca41156b86948f658e07eda922f06dc6c4284bbd179c6da108a48b4e5至此我们得到了签名，但是该签名与报文中的实际值并不相同。不仅如此，你会发现每次签名得到的结果都是不同的。这是因为 ECDSA 签名算法内部混入了随机值，即便使用同一私钥对同一消息进行多次签名，结果也会不同。  如果是 RSA 私钥，那么计算得到的 RSA 签名是可以与报文中的实际值对上的。使用同一私钥对同一消息进行多次签名，结果是相同的。不过这并不会影响验签的结果。下面我们进行验签。实际验签时，客户端会从服务器证书中提取出公钥。如下，文件以 \\n 结尾。# extract the public key from the server certificateopenssl x509 -in server-ecc-cert.pem -pubkey -noout &amp;gt; server-ecc-pub.pem# server public key-----BEGIN PUBLIC KEY-----MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE4Q+9ZBPkV4b2buqwPLB9EskoGByXTcPuF22znhtFG2R9gVlFyU4S3GyXx3QaFOfLLNdyl/puch+GlZAZZsYKPw==-----END PUBLIC KEY-----# server public key hexxxd -ps server-ecc-pub.pem | tr -d &quot;\\n&quot; | sed &#39;s/\\(..\\)/\\\\x\\1/g&#39;\\x2d\\x2d\\x2d\\x2d\\x2d\\x42\\x45\\x47\\x49\\x4e\\x20\\x50\\x55\\x42\\x4c\\x49\\x43\\x20\\x4b\\x45\\x59\\x2d\\x2d\\x2d\\x2d\\x2d\\x0a\\x4d\\x46\\x6b\\x77\\x45\\x77\\x59\\x48\\x4b\\x6f\\x5a\\x49\\x7a\\x6a\\x30\\x43\\x41\\x51\\x59\\x49\\x4b\\x6f\\x5a\\x49\\x7a\\x6a\\x30\\x44\\x41\\x51\\x63\\x44\\x51\\x67\\x41\\x45\\x34\\x51\\x2b\\x39\\x5a\\x42\\x50\\x6b\\x56\\x34\\x62\\x32\\x62\\x75\\x71\\x77\\x50\\x4c\\x42\\x39\\x45\\x73\\x6b\\x6f\\x47\\x42\\x79\\x58\\x0a\\x54\\x63\\x50\\x75\\x46\\x32\\x32\\x7a\\x6e\\x68\\x74\\x46\\x47\\x32\\x52\\x39\\x67\\x56\\x6c\\x46\\x79\\x55\\x34\\x53\\x33\\x47\\x79\\x58\\x78\\x33\\x51\\x61\\x46\\x4f\\x66\\x4c\\x4c\\x4e\\x64\\x79\\x6c\\x2f\\x70\\x75\\x63\\x68\\x2b\\x47\\x6c\\x5a\\x41\\x5a\\x5a\\x73\\x59\\x4b\\x50\\x77\\x3d\\x3d\\x0a\\x2d\\x2d\\x2d\\x2d\\x2d\\x45\\x4e\\x44\\x20\\x50\\x55\\x42\\x4c\\x49\\x43\\x20\\x4b\\x45\\x59\\x2d\\x2d\\x2d\\x2d\\x2d\\x0a使用公钥验签。# verify the signatureopenssl dgst -verify server-ecc-pub.pem -signature sig -sha256 dataVerified OK验证通过。为什么验签要使用证书而不能直接使用公钥？现有两个人 A 和 B，B 用自己的私钥签名了一段信息，发给 A。现在 A 用 B 的公钥验签，发现能够成功解密，所以以此认定信息的发送者是 B。这似乎没有问题，为什么还需要公钥证书呢？问题的关键在于，B 的公钥是否可信，B 的公钥是否真的是 B 的公钥。如果有中间人攻击，攻击者 C 掉包了 B 的公钥为自己的公钥，然后自己签名发送一段信息给 A，那么 A 就会误以为信息的发送者是 B，而实际发送者却是 C。所以，有必要确保公钥的确是 B 的，而证书能够证明这一点。证书由广受社会信任的 CA 签发，其中包含了公钥本身和公钥所代表的身份信息。A 在收到 B 的证书后，使用 CA 的证书验证 B 的证书，验证通过即代表 B 的证书的确是由 CA 签发的，CA 信任 B 的身份，而 CA 是广受信任的，A 自然也信任 CA，于是 A 可以信任 B 的身份，也即：只要验过了证书，就可以相信公钥所代表的身份，就证明公钥的确属于它所代表的那个身份机构。即便攻击者掉包 B 的公钥，他也无法伪造 CA 的签名，所以攻击者是无法伪造证书的。证书/信任链机制以 CA 这样的第三方权威机构作背书，能够防范中间人攻击，确保公钥的真实性。以下情况都没有使用证书：  ssh连接新服务器时，服务器会发来自己的公钥，用户可以选择是否信任该公钥，通常都会选择yes。ssh会记录下该服务器ip/域名和其对应的公钥，并且以后都予以信任。若服务器的公钥突然发生改变，ssh将发出警告，提示用户警惕连接对象的真实性。  日常我们自己使用ssh时，都是亲自将自己客户端的公钥放到服务器上，服务器也是直接信任这些公钥的。  使用github作为git远程库，git也会通过ssh以公私钥的形式连接github。用户通常需要先登录自己的账号，也就是先过一遍身份认证，然后亲自把自己的公钥放到github上，以后github就会直接信任该公钥代表的身份。如果 A 能够直接信任 B，直接认可公钥的真实性，这就不需要证书了。A 以后直接使用公钥验签即可。然而，在开放的网络通信中，证书/信任链机制不可或缺。TLS 算法名称的含义在熟悉了握手的知识以后，我们再来理解算法名称的含义。这并没有想象中那么简单，由于算法版本的更迭，算法名称的含义会有一些差别。先贴上几个算法名称的例子：TLS_RSA_WITH_AES_256_CBC_SHA256TLS_RSA_WITH_AES_128_GCM_SHA256TLS_RSA_WITH_AES_256_GCM_SHA384TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHATLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384TLS_ECDH_RSA_WITH_AES_256_CBC_SHATLS_ECDH_ECDSA_WITH_AES_256_CBC_SHASHA 是指 HMAC 计算以及 Finished 校验等流程所使用的哈希算法，CBC/GCM 是分组密码工作模式，AES_256 是共享密码算法和共享密钥长度。紧跟在 TLS 后面的 RSA/ECDHE/ECDH 是密钥交换算法，其中 DHE 密钥交换过程中会用到签名，所以后面还跟了一个签名算法——ECDSA/RSA。问题出现了，ECDH 密钥交换中，ECDH 密钥对不是临时生成的，服务器是直接将证书作为 ECDH 公钥发给客户端的，这个过程中服务器不需要进行额外的签名，那为什么会存在 ECDH_RSA/ECDH_ECDSA 这样的算法名称呢？这涉及一个被广泛误解的问题：算法名称中的签名算法到底是指证书上所使用的签名还是握手过程中所使用的签名？搞清这个问题大概没什么实用价值，但不搞清实在让我不舒服😣。在一众 RFC 中，我逐渐找到了答案。RFC4346  The Transport Layer Security (TLS) Protocol Version 1.1# 7.4.2  Server CertificateThe certificate type MUST be appropriate for the selected ciphersuite&#39;s key exchange algorithm, and is generally an X.509v3certificate.  It MUST contain a key that matches the key exchangemethod, as follows.  Unless otherwise specified, the signingalgorithm for the certificate MUST be the same as the algorithmfor the certificate key.  Unless otherwise specified, the publickey MAY be of any length.Key Exchange Algorithm  Certificate Key TypeRSA                     RSA public key; the certificate MUST                        allow the key to be used for encryption.DHE_DSS                 DSS public key.DHE_RSA                 RSA public key that can be used for                        signing.DH_DSS                  Diffie-Hellman key. The algorithm used                        to sign the certificate MUST be DSS.DH_RSA                  Diffie-Hellman key. The algorithm used                        to sign the certificate MUST be RSA.这是 TLS1.1 的 RFC。上面的意思是：证书的签名算法必须与确定密钥对类型的算法保持一致。文中还举了几个例子：            密钥交换算法      密钥对类型      握手签名算法（推理）      证书签名算法（推理）                  RSA      RSA      /      RSA              DHE_DSS      DSS      DSS      DSS              DHE_RSA      RSA      RSA      RSA              DH_DSS      DH      /      DSS              DH_RSA      DH      /      RSA        注（AI）：DSS 是一个数字签名标准，DSA 算法是其最初的核心实现，随着 DSS 标准的版本更新，RSA 和 ECDSA 也被纳入标准中。我们可以发现上表中的两个 DH 密钥交换算法没有遵守“证书的签名算法必须与确定密钥对类型的算法保持一致”的规定，这是因为 DH 算法只能用作密钥交换，不能用来签名，这才额外追加了一个算法名称，用于指定证书的签名算法。RFC4346  The Transport Layer Security (TLS) Protocol Version 1.1# F.1.1.3  Diffie-Hellman Key Exchange with AuthenticationWhen Diffie-Hellman key exchange is used, the server can eithersupply a certificate containing fixed Diffie-Hellman parameters oruse the server key exchange message to send a set of temporaryDiffie-Hellman parameters signed with a DSS or RSA certificate.Temporary parameters are hashed with the hello.random values beforesigning to ensure that attackers do not replay old parameters.  Ineither case, the client can verify the certificate or signature toensure that the parameters belong to the server.这段说明服务器可以通过两种方式提供 DH 参数：一种是直接发送 DH 证书，客户端通过验证证书证明 DH 参数的确属于服务器；一种是发送带签名的临时生成的 DHE 参数，客户端通过验签证明 DHE 参数的确属于服务器。这段至少可以佐证我对 DH 和 DHE 的理解是正确的。RFC4492  Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)# 2.1  ECDH_ECDSAIn ECDH_ECDSA, the server’s certificate MUST contain an ECDH-capablepublic key and be signed with ECDSA.# 2.2  ECDHE_ECDSAIn ECDHE_ECDSA, the server’s certificate MUST contain an ECDSAcapable public key and be signed with ECDSA.# 2.3  ECDH_RSAThis key exchange algorithm is the same as ECDH_ECDSA except that theserver’s certificate MUST be signed with RSA rather than ECDSA.# 2.4  ECDHE_RSAThis key exchange algorithm is the same as ECDHE_ECDSA except thatthe server’s certificate MUST contain an RSA public key authorizedfor signing, and that the signature in the ServerKeyExchange messagemust be computed with the corresponding RSA private key.  The servercertificate MUST be signed with RSA.这是 TLS1.1 ECC 算法的 RFC。所述逻辑也是类似的，与上面的说法都对得上。问题总结 - TLS1.1：  证书的签名算法必须与确定密钥对类型的算法保持一致。  RSA 密钥交换中没有签名的过程，故算法名称中没有签名算法。证书的签名算法须为 RSA。  DHE 密钥交换中有签名的过程，故算法名称中指定了签名算法，如 ECDHE_RSA。证书的签名算法须与该签名算法一致。  DH 密钥交换中没有签名的过程，其算法名称中本不需要指定签名算法，然证书的签名算法须与确定密钥对类型的算法（DH）保持一致，而 DH 算法无法用于签名，故算法名称中额外指定了证书的签名算法，如 ECDH_RSA。RFC5246  The Transport Layer Security (TLS) Protocol Version 1.2# A.7  Changes to RFC 4492As described in Sections 7.4.2 and 7.4.6, the restrictions on thesignature algorithms used to sign certificates are no longer tied tothe cipher suite (when used by the server) or theClientCertificateType (when used by the client).  Thus, therestrictions on the algorithm used to sign certificates specified inSections 2 and 3 of RFC 4492 are also relaxed.# 7.4.2  Server CertificateIf the client provided a &quot;signature_algorithms&quot; extension, then allcertificates provided by the server MUST be signed by ahash/signature algorithm pair that appears in that extension.  Notethat this implies that a certificate containing a key for onesignature algorithm MAY be signed using a different signaturealgorithm (for instance, an RSA key signed with a DSA key).  This isa departure from TLS 1.1, which required that the algorithms be thesame.  Note that this also implies that the DH_DSS, DH_RSA,ECDH_ECDSA, and ECDH_RSA key exchange algorithms do not restrict thealgorithm used to sign the certificate.  Fixed DH certificates MAY besigned with any hash/signature algorithm pair appearing in theextension.  The names DH_DSS, DH_RSA, ECDH_ECDSA, and ECDH_RSA arehistorical.# 7.4.1.4.1  Signature AlgorithmsThe client uses the &quot;signature_algorithms&quot; extension to indicate tothe server which signature/hash algorithm pairs may be used indigital signatures.# 7.4.1.4.1  Signature AlgorithmsThe semantics of this extension are somewhat complicated because thecipher suite indicates permissible signature algorithms but not hashalgorithms.  Sections 7.4.2 and 7.4.3 describe the appropriate rules.# 7.4.3  Server Key Exchange MessageIf the client has offered the &quot;signature_algorithms&quot; extension, thesignature algorithm and hash algorithm MUST be a pair listed in thatextension.  Note that there is a possibility for inconsistencieshere.  For instance, the client might offer DHE_DSS key exchange butomit any DSA pairs from its &quot;signature_algorithms&quot; extension.  Inorder to negotiate correctly, the server MUST check any candidatecipher suites against the &quot;signature_algorithms&quot; extension beforeselecting them.  This is somewhat inelegant but is a compromisedesigned to minimize changes to the original cipher suite design.这是 TLS1.2 的 RFC。新增了 signature_algorithms 扩展字段，它代表了客户端支持的签名算法。密钥交换过程中可能用到的签名算法由此字段协商而来。证书的签名算法不再受 TLS 算法名称约束，只须位列 signature_algorithms 所支持的算法列表中。对于密钥交换过程中可能出现的签名过程，TLS 算法名称中只指定了签名算法，却没有哈希算法（名称中的哈希算法为 HMAC 或 Finished 报文所用），遂有 signature_algorithms，其中的名称同时包含了签名和哈希算法。如此，TLS 算法名称和扩展字段都给出了签名算法名称，为同时满足二者约束，服务器必须予以检查，最终协商选择出的签名算法须同时兼容 TLS 算法名称和扩展字段。举例，若 TLS 算法名称为 ECDHE_ECDSA，扩展 signature_algorithms 中含有 ecdsa_secp256r1_sha256, rsa_pkcs1_sha256，那么服务器应协商选择出 ecdsa_secp256r1_sha256 作为签名算法。既如此，证书应选用 ECC 证书，但证书自己的签名可以是 RSA。另，对于静态 DH 密钥交换算法如 ECDH_ECDSA, ECDH_RSA，其名称中的签名算法已经不含有任何实际约束意义，此类迷惑性十足的名称之存在皆系历史原因。RFC8422  Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and Earlier# 2.1  ECDHE_ECDSAIn ECDHE_ECDSA, the server’s certificate MUST contain an ECDSA- orEdDSA-capable public key.# 2.2  ECDHE_RSAThis key exchange algorithm is the same as ECDHE_ECDSA except thatthe server’s certificate MUST contain an RSA public key authorizedfor signing and the signature in the ServerKeyExchange message mustbe computed with the corresponding RSA private key.这是 TLS1.2 出现后，有关 ECC 算法的 RFC。相比 RFC4492 的表述，该表述没有再特别提及证书本身的签名应为何算法，因为证书的签名算法已不再受 TLS 算法名称约束，只要位列 signature_algorithms 的算法列表，是什么算法都有可能。问题总结 - TLS1.2：  密钥交换过程中可能用到的签名算法根据客户端支持的 TLS 算法和 signature_algorithms 扩展协商而来。  证书的签名算法不再受 TLS 算法名称约束，只须位列 signature_algorithms 所支持的算法列表中。  静态 DH 密钥交换算法如 ECDH_ECDSA, ECDH_RSA，其名称中的签名算法不具有任何实际约束意义，此类名称之存在皆系历史原因。问题结论：TLS 算法名称中的签名算法基本指的是握手过程中所使用的签名，而非特指证书本身的签名，不过二者也并非毫无关联，具体细节参见上面的分析和总结。构建证书链尝试使用 openssl 构建如下证书链。Root CA Cert -&amp;gt; Intermediate CA Cert -&amp;gt; End Entity Cert根 CA 作为信任锚点，它的证书是自签名证书；根 CA 给中级 CA 颁发中级证书；中级 CA 给用户颁发末端证书。# build the root cert# generate private key for the root caopenssl genrsa -out root-ca-key.pem 2048# generate cert sign request of the root ca# here the key content of the `openssl-ca.cnf` will show at the endopenssl req -new -key root-ca-key.pem -out root-ca-csr.pem -config openssl-ca.cnf# fill the prompted fields like followsCountry Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:ZhejiangLocality Name (eg, city) []:HangzhouOrganization Name (eg, company) [Internet Widgits Pty Ltd]:lcatmiaoOrganizational Unit Name (eg, section) []:lcatmiao-caCommon Name (e.g. server FQDN or YOUR name) []:lcatmiao-ca.comEmail Address []:lcatmiao@test.com# self-sign the public key retrived implicitly from the cert sign request # of the root ca with the private key of also the root ca then get the # root certopenssl x509 -req -days 3650 -sha256 -extfile openssl-ca.cnf -extensions v3_ca -in root-ca-csr.pem -signkey root-ca-key.pem -out root-ca-cert.pem# build the intermediate cert# generate private key for the intermediate caopenssl genrsa -out intermediate-ca-key.pem 2048# generate cert sign request of the intermediate caopenssl req -new -key intermediate-ca-key.pem -out intermediate-ca-csr.pem -config openssl-ca.cnf# fill the prompted fields like followsCountry Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:ZhejiangLocality Name (eg, city) []:HangzhouOrganization Name (eg, company) [Internet Widgits Pty Ltd]:lcatmiaoOrganizational Unit Name (eg, section) []:lcatmiao-caCommon Name (e.g. server FQDN or YOUR name) []:lcatmiao-ca.comEmail Address []:lcatmiao@test.com# sign the public key retrived implicitly from the cert sign request # of the intermediate ca with the private key of the root ca then # get the intermediate certopenssl x509 -req -days 3650 -sha256 -extfile openssl-ca.cnf -extensions v3_ca -in intermediate-ca-csr.pem -CA root-ca-cert.pem -CAkey root-ca-key.pem -CAcreateserial -out intermediate-ca-cert.pem# build the end entity cert# generate private key for the end entityopenssl genrsa -out end-entity-key.pem 2048# generate cert sign request of the end entity# here the key content of the `openssl-user.cnf` will show at the endopenssl req -new -key end-entity-key.pem -out end-entity-csr.pem -config openssl-user.cnf# fill the prompted fields like followsCountry Name (2 letter code) [AU]:CNState or Province Name (full name) [Some-State]:ZhejiangLocality Name (eg, city) []:HangzhouOrganization Name (eg, company) [Internet Widgits Pty Ltd]:lcatmiaoOrganizational Unit Name (eg, section) []:lcatmiao-userCommon Name (e.g. server FQDN or YOUR name) []:172.168.10.110Email Address []:lcatmiao@test.com# sign the public key retrived implicitly from the cert sign request # of the end entity with the private key of the intermediate ca then # get the end entity certopenssl x509 -req -days 3650 -sha256 -extfile openssl-user.cnf -extensions usr_cert -in end-entity-csr.pem -CA intermediate-ca-cert.pem -CAkey intermediate-ca-key.pem -CAcreateserial -out end-entity-cert.pem# After doing all the operations above, `ls` shows that # all the files we have are as follows.end-entity-cert.pemend-entity-csr.pemend-entity-key.pemintermediate-ca-cert.pemintermediate-ca-cert.srlintermediate-ca-csr.pemintermediate-ca-key.pemopenssl-ca.cnfopenssl-user.cnfroot-ca-cert.pemroot-ca-cert.srlroot-ca-csr.pemroot-ca-key.pem# we can see the cert info by using this cmdopenssl x509 -in end-entity-cert.pem -noout -text# key content of the openssl-ca.cnf# the following is just a test example that only lists the modified cfg items[ req ]req_extensions = v3_req # The extensions to add to a certificate request[ v3_req ]basicConstraints = CA:TRUE# keyUsage = nonRepudiation, digitalSignature, keyEnciphermentsubjectAltName = @alt_names[ v3_ca ]subjectAltName = @alt_names[ alt_names ]DNS.1 = lcatmiao-ca.com# key content of the openssl-user.cnf# the following is just a test example that only lists the modified cfg items[ req ]req_extensions = v3_req # The extensions to add to a certificate request[ usr_cert ]subjectAltName = @alt_names[ v3_req ]basicConstraints = CA:FALSE# keyUsage = nonRepudiation, digitalSignature, keyEnciphermentsubjectAltName = @alt_names[ alt_names ]IP.1 = 172.168.10.110IP.2 = 172.168.10.105IP.3 = 172.168.10.106IP.4 = 172.168.10.107IP.5 = 172.168.10.108至此，一个简单的证书链就构建好了。下面我们来验证一下这个证书链。# verify the root cert which is a self-sign certopenssl verify -CAfile root-ca-cert.pem root-ca-cert.pem# output:root-ca-cert.pem: OK# verify the intermediate certopenssl verify -trusted root-ca-cert.pem intermediate-ca-cert.pem# output:intermediate-ca-cert.pem: OK# verify the end entity certopenssl verify -partial_chain -trusted intermediate-ca-cert.pem end-entity-cert.pem# output:end-entity-cert.pem: OK# directly verify the whole cert chain which has only three levelsopenssl verify -CAfile root-ca-cert.pem -untrusted intermediate-ca-cert.pem end-entity-cert.pem# output:end-entity-cert.pem: OK本地使用命令行都能验过，不代表网络通信时也能验过。实际通信的行为受各种配置的影响 ，比如实测发现末端证书中配置的 IP 地址或者域名要与服务器保持一致，否则不通。顺带一提，实际报文中，证书链的顺序：末端证书在前，中级证书按层级顺序依次跟随，根证书一般不包含在链中。RFC5246  The Transport Layer Security (TLS) Protocol Version 1.2# 7.4.2  Server Certificatecertificate_list   This is a sequence (chain) of certificates.  The sender&#39;s   certificate MUST come first in the list.  Each following   certificate MUST directly certify the one preceding it.  Because   certificate validation requires that root keys be distributed   independently, the self-signed certificate that specifies the root   certificate authority MAY be omitted from the chain, under the   assumption that the remote end must already possess it in order to   validate it in any case.消除浏览器安全警告当客户端（浏览器）没能验过服务器发来的证书时，就会显示如下的安全警告页面，并且 URI 栏会有“不安全”的提示。如果服务器的证书是我们自己签发的，自然无法被浏览器内置的 CA 证书验过，我们需要将自己生成的根证书导入浏览器才行。将自己生成的根证书导入浏览器，作为受信任的颁发机构。此后再访问服务器，就是正常的 https 访问了。  如果服务器发来的证书不止一个，而是多级证书，即证书链的一部分，那么理论上导入浏览器的证书应该是证书链的另一部分，二者合一要能构成完整的证书链才行。参考资料  《图解HTTP》  Keyless SSL: The Nitty Gritty Technical Details  The Illustrated TLS Connection: Every Byte Explained  RFC4346  The Transport Layer Security (TLS) Protocol Version 1.1  RFC4492  Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)  RFC5246  The Transport Layer Security (TLS) Protocol Version 1.2  RFC8422  Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and Earlier  RFC7919  Negotiated Finite Field Diffie-Hellman Ephemeral Parameters for Transport Layer Security (TLS)脚注            使用会话密钥加密后的 Client Finished 报文。 &amp;#8617; &amp;#8617;2              使用会话密钥加密后的 Server Finished 报文。 &amp;#8617; &amp;#8617;2              使用会话密钥加密后的 Close Notify 报文。 &amp;#8617;      "
  },
  
  {
    "title": "真值与内存的相互转换",
    "url": "/posts/%E7%9C%9F%E5%80%BC%E4%B8%8E%E5%86%85%E5%AD%98%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/",
    "categories": "Tech, C",
    "tags": "",
    "date": "2024-03-30 17:58:00 +0800",
    





    "snippet": "概念定义&amp;gt; 真值实际意义上的值，比如代码里直接书写的值。&amp;gt; 内存值这个词是笔者自己造的，用于特指存储在内存中的值。笔者对这个概念还有如下规定或结论：  内存值都是无符号的。  习惯称“n进制内存值”为“内存n进制”，比如称“二进制内存值”为“内存二进制”。  内存值与其对应的无符号真值是相等的。&amp;gt; 内存值分布这个词是笔者自己造的，用于表示内存值的各个字节在内存中的具体分布情况。举例有符号真值：// 有符号十进制真值-255// 有符号二进制真值-00000000 00000000 00000000 11111111(1,0000000 00000000 00000000 11111111)// 有符号十六进制真值-0x00 00 00 ff(0x80 00 00 ff)经过有符号转换后，内存值为：// 内存十进制4294967041// 内存二进制11111111 11111111 11111111 00000001// 内存十六进制0xff ff ff 01该内存值对应的内存值分布如下：将上述内存值转换为无符号真值：// 无符号十进制真值4294967041// 无符号二进制真值11111111 11111111 11111111 00000001// 无符号十六进制真值0xff ff ff 01补充说明&amp;gt; 说明1一般来说，编程语言和各种调试工具中，无法直接打印内存二进制（没有对应的格式说明符）；只能以无符号形式打印内存八进制、内存十六进制；可以以无符号或有符号形式打印内存十进制。&amp;gt; 说明2对于有符号十六进制真值 -0x00 00 00 ff，我们人类可以把负号写进去得到 0x80 00 00 ff，这看起来似乎是一样的。然而，在C语言中，以 %d 打印这两个数的输出结果是不一样的。printf(&quot;%d\\n&quot;, -0xff);  // -255printf(&quot;%d\\n&quot;, 0x800000ff); // -2147483393详细分析：关于常量的类型判断，可参考C11-6.4.4.1-Integer constants-ISO/IEC 9899:201x。0xff 这个常量被存储为 int，其内存二进制为：00000000 00000000 00000000 11111111对它进行取负运算后，其内存二进制为：11111111 11111111 11111111 00000001%d 以有符号十进制形式打印该内存二进制，得到 -255：11111111 11111111 11111111 00000001 -&amp;gt;1,1111111 11111111 11111111 00000001 -&amp;gt;1,0000000 00000000 00000000 11111110 -&amp;gt;1,0000000 00000000 00000000 11111111 -&amp;gt;-2550x800000ff 这个常量会被当成一个正数，C尝试将其存储为 int，发现不够存，于是进一步尝试存储为 unsigned int，发现够存，于是该常量最终被存储为 unsigned int，其内存二进制为：10000000 00000000 00000000 11111111%d 以有符号十进制形式打印该内存二进制，得到 -2147483393：10000000 00000000 00000000 11111111 -&amp;gt;1,0000000 00000000 00000000 11111111 -&amp;gt;1,1111111 11111111 11111111 00000000 -&amp;gt;1,1111111 11111111 11111111 00000001 -&amp;gt;-2147483393关键在于：我们眼中的 0x800000ff 是一个负数，它等效于 -0x00 00 00 ff，但C语言会把它当成一个正数看待，然后使用存得下它的类型作为它的数据类型，换言之，在C语言中，-0x00 00 00 ff 的写法和 0x800000ff 的写法表示的完全是两个数。"
  },
  
  {
    "title": "C语言标准发展历史",
    "url": "/posts/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2/",
    "categories": "Tech, C",
    "tags": "",
    "date": "2024-02-24 16:53:37 +0800",
    





    "snippet": "对各种 C 标准进行简述。参考资料：Standards (Using the GNU Compiler Collection (GCC))ANSI C，ISO C89/90ANSI C 是最初的 C 语言标准，在 1989 年获得批准，1990 年发布。1990 年晚些时候，该标准成为了 ISO C89/90 标准。这两个标准之间没有技术上的差异，可以当作就是一个标准。C94/95 是这一标准的修订版本。ISO C991999 年，ISO 发布了新的 C 标准，即 ISO C99。ISO C11，ISO C172011 年，ISO 发布了新的 C 标准，即 ISO C11。2017 年，ISO 编制了一个修正版本，并于 2018 年发布，该版本成为了新的 C 标准，即 ISO C17。在 gcc 中，可通过 -std=c11 或 -std=iso9899:2011 指定 C11 标准；通过 -std=c17 或 -std=iso9899:2017 指定 C17 标准。若通过 -std=c11 指定 C11 标准，也会应用 C17 中的修正，只不过 __STDC_VERSION__ 的值为 C11 对应的值，除此以外和 C17 没有区别。GNU Extensions标准是标准，实现是实现。gcc 在实现上述标准的同时也添加了一些自己的扩展功能。把带 GNU 扩展的 C 标准直接当作 GNU C 标准，问题也不大。例如可以指定 -std=gnu90 (for C90 with GNU extensions)、-std=gnu99 (for C99 with GNU extensions)、-std=gnu11 (for C11 with GNU extensions)。gcc 将一些 C99 中的特性作为 C90 模式的扩展，将一些 C11 中的特性作为 C90 和 C99 模式的扩展。这个按我的理解，大概可以这么看：只有经过了广泛的实践和时间检验的特性才能被写入标准。gcc 扩展就像是先行者，在经过广泛检验后，被接受为新标准的一部分。"
  },
  
  {
    "title": "函数传参",
    "url": "/posts/%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82/",
    "categories": "Tech, C",
    "tags": "",
    "date": "2022-11-27 23:30:00 +0800",
    





    "snippet": "传参分类从传参类型上看传参分为传值和传指针。  传指针本质上也是传值，只不过传的是指针值。由于传一般值和传指针值还是有点区别，所以分成两种说法。传值一般就指传一般值，传指针专门用于描述传指针值。从传参行为上看传参分为值复制和传自己。  传自己本质上也是值复制，只不过是取地址传无名指针，形参直接接上；而不是直接传有名指针。例如：// 函数调用func1(id, index, flag, &amp;amp;count);func2(arr);// 函数定义头func1(int id, int index, int flag, int *p_count)func2(int *arr)其中，id，index，flag 是值复制，这毫无疑义。arr 是数组名，这里退化为指针，直接进行了传参，也就是我说的“直接传有名指针”，所以我将其归为值复制。&amp;amp;count 是取地址传无名指针，然后形参直接接上，是传自己。传参分析传值是值复制。传指针有两种情况，第一种是值复制，第二种是传自己，如图所示。以下是一些经验，不一定正确，只能说这些场景遇到的比较多，看个眼熟就成。  值复制倾向于使用，传自己倾向于赋值。  一般而言，实参直接传为值复制，实参取地址为传自己。多数情况下，实参取地址可以理解为赋值。  形参中的值变量属于值复制，形参中的指针变量有上图两种情况。（其实就是传参分析的两条，这里着眼于形参。该经验一定正确。）  无论是为了使用还是赋值，传数组一般直接传数组名。  以 char 为例。函数形参中，经常能看见 const char * 和 char * 的使用。const char * 显然不会更改指针所指向内存的内容，但是 char * 就可能更改指针所指向的内容，这一点在实践中值得注意，即我们的内存传递给 char * 后有可能会被更改。这里对经验4多说几句。我曾经以为，若是为了给数组赋值，应该对数组名取地址传参。一是因为输出参数一般都加&amp;amp;，写成类似下面这样，一眼就能看出哪些是出参，可读性高。二是觉得平时数组指针的概念都没怎么用过，在这里正好用起来，岂不美哉。// 这是问题写法#include &amp;lt;stdio.h&amp;gt;void func(int, int (*)[], int *);int main(){    int i = 0;    int arr[10] = {0};    int count = 5;    int sum = 0;    func(count, &amp;amp;arr, &amp;amp;sum);    for (i = 0; i &amp;lt; count; i++)    {        printf(&quot;%d\\n&quot;, arr[i]);    }    printf(&quot;sum = %d\\n&quot;, sum);        return 0;}void func(int count, int (*parr)[10], int *p_sum){    int i = 0;    int sum = 0;    for (i = 0; i &amp;lt; count; i++)    {        (*parr)[i] = i;        // parr[0][i] = i;        sum += i;    }    *p_sum = sum;}然而后来我发现了自己的错误，不要这样传参。  原因一：没人这么用。  原因二：memcpy()，snprintf() 这种库函数，平时使用的时候都是直接传数组名的。  原因三：可读性未必好。出参都加了&amp;amp;，算是满足了强迫症，但是函数定义里面就要写成 (*parr)[i] = i 或者 parr[0][i] = i ，这显得复杂。  原因四：性能不佳。使用的时候，(*parr)[i] = i 或者 parr[0][i] = i 要取值两次。  原因五：数组指针有用，但压根不是这么用的。直接传二维数组名的时候，形参就得定义数组指针，这才是数组指针正常的用法。所以给数组名取地址传参是多此一举。上述例子的正确写法应为：// 这是正常写法#include &amp;lt;stdio.h&amp;gt;void func(int, int *, int *);int main(){    int i = 0;    int arr[10] = {0};    int count = 5;    int sum = 0;    func(count, arr, &amp;amp;sum);    for (i = 0; i &amp;lt; count; i++)    {        printf(&quot;%d\\n&quot;, arr[i]);    }    printf(&quot;sum = %d\\n&quot;, sum);        return 0;}void func(int count, int *p, int *p_sum){    int i = 0;    int sum = 0;    for (i = 0; i &amp;lt; count; i++)    {        p[i] = i;        sum += i;    }    *p_sum = sum;}"
  },
  
  {
    "title": "记一次指针强转导致脏数据写入问题",
    "url": "/posts/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8C%87%E9%92%88%E5%BC%BA%E8%BD%AC%E5%AF%BC%E8%87%B4%E8%84%8F%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E9%97%AE%E9%A2%98/",
    "categories": "Tech, C",
    "tags": "",
    "date": "2022-11-26 11:40:00 +0800",
    





    "snippet": "交接项目的时候遇到的一个问题，涉及指针、字节序、结构体内存对齐相关知识，三大知识包含规则的共同作用导致了这一问题。问题描述时间有些久远了，结合下图来讲，总之，就是变量 vsys_id 莫名其妙地被更改了。当时检查了可能出现问题的相关函数，以及函数传参过程，均没有发现问题所在，甚至在这些地方连 vsys_id 变量名都没有出现，以至于一直没能定位问题。最后发现 vsys_id 被脏数据写入了，也就是说，我们更改变量 policy_id 的同时把 vsys_id 也给改了，从而导致了问题。问题分析根据结构体内存对齐画出结构，可以发现 vsys_id 和 policy_id 是紧挨着的。原先指向 policy_id 的指针是 u16 * ，原代码对其进行了一个强转成 u32 * 的操作，这样一来，这个指针就指向了 policy_id 加 vsys_id 的4个字节，然后原代码对该指针取值赋值1，相当于把这4个字节当成一个变量赋值了。这里似乎是由于传参的时候类型不匹配，于是使用了强转，具体为什么要强转也记不太清了。总之按照正常的逻辑，代码其实是要对 policy_id 赋值成1。强转后赋值的情况如图所示，在X86架构下，的确只是对 policy_id 赋值成1，没什么不对的，所以测试的时候X86架构没啥问题；在MIPS架构下，由于字节序相反，1反而是写给了 vsys_id ，从而引发了问题。  结构体内存对齐这里不赘述，简单来说就是：  成员的偏移量要是自身大小的整数倍，  结构体总大小要是最大成员大小的整数倍。    至于字节序，图中描述已经很清楚。本来是给 policy_id 赋值，却同时改掉了相邻的 vsys_id 的值，也难怪乍一看定位不了问题。最后理解了问题成因，也就顺利解决了。本文对导致该问题的原因做一个记录。"
  },
  
  {
    "title": "C-Cpp中的const关键字",
    "url": "/posts/C-Cpp%E4%B8%AD%E7%9A%84const%E5%85%B3%E9%94%AE%E5%AD%97/",
    "categories": "Tech, C",
    "tags": "",
    "date": "2022-05-08 21:30:00 +0800",
    





    "snippet": "记录一波 const 关键字的知识点。概述const 意为不可修改。const 修饰的变量不可被修改， 是只读变量，也称这样的变量为常量。const 修饰的变量不可修改这一点是语法层面的限制，通过一些刻意构造的操作仍然可以修改变量的值，只是一般不会这样做。const 也可以修饰指针，既可以限制指针指向的数据，又可以限制指针本身。const 修饰变量const int VexNum = 20;int const VexNum = 20;上述两种写法的效果是一样的。我们一般使用第一种。const 修饰变量，即定义了常量 VexNum。  const 定义的常量一般单词首字母大写。这个时候企图修改常量是不行的。VexNum = 30; // error: assignment of read-only variable &#39;VexNum&#39;由于常量在后期不能被更改，所以定义常量时必须初始化。const 修饰指针const int *p;int const *p;    int * const p = &amp;amp;m;第一、二种写法等效，指针指向的数据不可修改，定义了常量指针；第三种写法是指针本身不可修改，定义了指针常量。  可以这样记忆：const 离指针近，指针本身不可修改，是指针常量；const 离指针远，指针指向的数据不可修改，是常量指针。第一、二种写法定义常量指针，定义时可以不初始化；第三种写法定义指针常量，由于指针常量在后期不能被修改，所以定义指针常量时必须初始化。上述写法本质上是两种写法，这两种写法也可以合到一起，如下：const int * const p = &amp;amp;m;int const * const p = &amp;amp;m;这种写法定义的指针，既是常量指针，又是指针常量。指针本身不能被修改，指针指向的数据也不能被修改。const 和非 const 指针之间的赋值将 const 指针赋值给非 const 指针，不可以。将非 const 指针赋值给 const 指针，可以。  方便记忆：去限制不行，加限制行。&amp;gt; 补充（2025.12.21）对于像 const char * const * const * const 这样复杂类型的赋值规则，粗略整理了一张图如下，不保证完全正确，但笔者尝试过一些例子，未见到反例。const 与字符串写这一块的原因是我发现字符串常量通常都用 const char * 接，但后来发现直接用 char * 接编译也没有报错，一时间产生了诸多疑惑，现将研究结果呈现如下。先说一下字符串。字符串本质上就是字符数组。这里我将字符串分为两类，一类是内存只读的字符数组，一类是内存可读可写的字符数组，前者就是字符串常量，后者可以理解为“字符串变量”。  C语言中并没有“字符串变量”的说法，平时大都直接用字符数组来称呼“字符串变量”，但其实无论是字符串常量还是“字符串变量”，本质上都是字符数组。由于我不喜欢用字符数组来称呼“字符串变量”，所以还是忍不住直接使用了“字符串变量”的说法，读者只要清楚这里的“字符串变量”是指内存可读可写的字符数组就行。我们在代码中直接书写的类似 &quot;abc&quot;，&quot;This is a string.&quot;，&quot;Fail to open db.&quot; 就是字符串常量，除此以外都是“字符串变量”。既然字符串是字符数组，那么指向首元素的指针就是 char *，用 char * 接字符串常量自然能过编译。// 能过编译char *str = &quot;abc&quot;;但是如果企图更改它的值，那就要出问题了。// 能过编译，但运行时会出错#include &amp;lt;stdio.h&amp;gt;int main(){    char *str = &quot;abc&quot;;    *str = &#39;A&#39;;    printf(&quot;%s\\n&quot;, str);        return 0;}字符串常量是内存只读的字符数组，强行改值自然要出问题。正因如此，通常会使用 const 关键字加以编译层面的检查，防止开发者无意间做出更改只读内存的操作。const char *str = &quot;abc&quot;;const 在 C 和 C++ 中的区别编译期替换#include &amp;lt;stdio.h&amp;gt;int main(){    const int m = 20;    int *p = (int *)&amp;amp;m;    *p = 40;    printf(&quot;%d\\n&quot;, m);    printf(&quot;%d\\n&quot;, *p);    return 0;}上述代码中，m 是常量，但我们通过指针仍然更改了它的值。&amp;amp;m 得到的是 const int * 类型，不能直接赋值给 int *，所以这里需要强转。最终我们更改了 m 常量在内存中的值。可见，const 的限制并不是绝对的，通过一些刻意的操作仍然可以修改，只是一般不会这样做。下面说一下 const 在 C 和 C++ 中的区别。上述代码在C中运行的结果如下：4040将同样的代码放到C++中运行：#include &amp;lt;iostream&amp;gt;using namespace std;int main(){    const int m = 20;    int *p = (int *)&amp;amp;m;    *p = 40;    cout &amp;lt;&amp;lt; m &amp;lt;&amp;lt; endl;    cout &amp;lt;&amp;lt; *p &amp;lt;&amp;lt; endl;    return 0;}结果为：2040原因在于：C++中的 `const` 会进行编译期替换，有点类似 #define，但 #define 是在预处理阶段。我们可以理解为，C++的代码，在经过编译后，变成了如下：#include &amp;lt;iostream&amp;gt;using namespace std;int main(){    const int m = 20;    int *p = (int *)&amp;amp;m;    *p = 40;    cout &amp;lt;&amp;lt; 20 &amp;lt;&amp;lt; endl;    cout &amp;lt;&amp;lt; *p &amp;lt;&amp;lt; endl;    return 0;}实际上 m 在内存中的值的确被改为了 40，只不过由于编译期替换，我们 cout &amp;lt;&amp;lt; m 直接变成了 cout &amp;lt;&amp;lt; 20，自然就输出了 20。而在C中运行时，就是正常执行，printf(&quot;%d\\n&quot;, m) 中 m 还是变量 m，程序读取变量 m 的值，发现是 40，就输出 40。C++少了读取变量内存的过程，提高了执行效率，但不能及时反应变量的修改；然而，一般也不会修改 const 变量。可见范围在C语言中，const 全局变量和普通全局变量一样，作用域是整个工程，只不过需要用 extern 声明一下才能在其它文件中使用。见如下代码：test1.c#include &amp;lt;stdio.h&amp;gt;extern const int m;int main(){    printf(&quot;%d\\n&quot;, m);    return 0;}test2.cconst int m = 20;编译命令：gcc test1.c test2.c -o test运行结果：20我们在 test2.c 中定义了 const 全局变量，在 test1.c 中通过 extern 声明之，便可以使用了。其实这里使用 extern int m; 声明也是可以的，但还是建议使用 extern const int m; 声明，因为使用后者能够启用相关的代码检查，具体说明如下：修改 test1.c 如下：#include &amp;lt;stdio.h&amp;gt;extern const int m;int main(){    // 这里尝试对const变量进行修改，无论是VSCode Linting还是gcc都会报错，这很正常。    m = 40;     printf(&quot;%d\\n&quot;, m);    return 0;}但若修改 test1.c 如下：#include &amp;lt;stdio.h&amp;gt;extern int m;int main(){    // 这里尝试对const变量进行修改，但无论是VSCode Linting还是gcc都没有报错，    // 但是生成的exe无法正常运行。    m = 40;     printf(&quot;%d\\n&quot;, m);    return 0;}综上所述，推荐使用 extern const int m; 进行声明，这样可以使相关代码检查能够正常工作，而且代码看上去更清楚，可读性更高。稍微扯远了点，现在我们回来，总之，在C语言中，const 全局变量和普通全局变量一样，作用域都是整个工程，只不过需要用 extern 声明一下才能在其它文件中使用。在C++中，`const` 全局变量的作用域仅是单个文件。 见如下代码：test1.cpp#include &amp;lt;iostream&amp;gt;using namespace std;extern const int m;int main(){    cout &amp;lt;&amp;lt; m &amp;lt;&amp;lt; endl;    return 0;}test2.cppconst int m = 20;编译命令：g++ test1.cpp test2.cpp -o test此时编译链接会出现错误：undefined reference to `m&#39;collect2.exe: error: ld returned 1 exit status因为C++中 const 全局变量的作用域仅是单个文件，用 extern 也没用。所以在C++中，下述代码是成立的：test1.cpp#include &amp;lt;iostream&amp;gt;using namespace std;const int m = 20;void func();int main(){    cout &amp;lt;&amp;lt; m &amp;lt;&amp;lt; endl;    func();    return 0;}test2.cpp#include &amp;lt;iostream&amp;gt;using namespace std;const int m = 40;void func(){    cout &amp;lt;&amp;lt; m &amp;lt;&amp;lt; endl;}运行结果：2040上面两个全局变量 m 互不影响，进行编译期替换，自然就能得到上述结果。至于内存，我认为全局区同时存在两个 m，编译器应该通过某种方式区分了它们。在 VSCode 调试中，我也能看到 m 的值既可以是 20，也可以是 40。如下图：当我在 main() 中时，只能看见 test1.cpp 中定义的 m，从全局区读取了 test1.cpp 中定义的 m 为 20。当我在 func() 中时，只能看见 test2.cpp 中定义的 m，从全局区读取了 test2.cpp 中定义的 m 为 40。总之，这样的代码在C中就不能成立，会出现重复定义全局变量的错误。C++中，在定义 `const` 全局变量时加上 `extern` 关键字可以将作用域从单个文件扩展到整个工程，此方法仅 `g++` 支持。 见如下代码：test1.cpp#include &amp;lt;iostream&amp;gt;using namespace std;extern const int m;int main(){    cout &amp;lt;&amp;lt; m &amp;lt;&amp;lt; endl;    return 0;}test2.cppextern const int m = 20;运行结果：20在 test2.cpp 中，使用 extern 定义了 const 全局变量，作用域是整个工程，在 test1.cpp 中使用 extern 声明一下后就可以使用了。const or #define如果只是为了像 const int a = 10;，#define MAX 20 这样定义一个常量，那么 const 和 #define 都可以用来定义。有的资料中说使用 const 定义常量时带了类型，编译时会有类型检查；#define 在预编译阶段只是替换，没有类型检查一说。这点心里有数就行。纯粹只是定义一个常量的话，C语言的风格更多使用 #define；C++两者都会用，const 很常见。"
  },
  
  {
    "title": "MySQL数据类型转换",
    "url": "/posts/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/",
    "categories": "Tech, SQL",
    "tags": "",
    "date": "2022-02-11 21:35:00 +0800",
    





    "snippet": "关于MySQL的数据类型转换问题大概两年前就研究过了，只是那时候没有发博客的习惯，笔记记得也很简单。最近又遇到了这个问题，打开以往的笔记发现记得太简单了，自己看完了还是有好多疑问😭，故有了这篇文章。  参考资料：  MySQL :: MySQL 8.0 Reference Manual :: 12.11 Cast Functions and Operators  MySQL :: MySQL 8.0 Reference Manual :: 12.3 Type Conversion in Expression Evaluation  mysql 类型自动化转换问题 - whendream - 博客园  谈谈MySQL隐式类型转换 - 知乎  测试版本：  MySQL 8.0.18显式转换cast()CAST(expr AS type [ARRAY])使用该函数可以进行强制类型转换。type：  signed：signed bigint类型  char：varchar类型  float  double# 将53.4转换为整数mysql&amp;gt; select cast(53.4 as signed);+----------------------+| cast(53.4 as signed) |+----------------------+|                   53 |+----------------------+1 row in set (0.00 sec)# 将53.6转换为整数mysql&amp;gt; select cast(53.6 as signed);+----------------------+| cast(53.6 as signed) |+----------------------+|                   54 |+----------------------+1 row in set (0.00 sec)# 将-53.4转换为整数mysql&amp;gt; select cast(-53.4 as signed);+-----------------------+| cast(-53.4 as signed) |+-----------------------+|                   -53 |+-----------------------+1 row in set (0.00 sec)# 将-53.6转换为整数mysql&amp;gt; select cast(-53.6 as signed);+-----------------------+| cast(-53.6 as signed) |+-----------------------+|                   -54 |+-----------------------+1 row in set (0.00 sec)# 将53.4转换为字符串mysql&amp;gt; select cast(53.4 as char);+--------------------+| cast(53.4 as char) |+--------------------+| 53.4               |+--------------------+1 row in set (0.00 sec)字符串转换为数字的规则      不以数字开头的字符串会被转换为0        以数字开头的字符串会被转换成开头的那些数字  此规则也适用于隐式转换。# 将字符串qwe456转换为整数mysql&amp;gt; select cast(&#39;qwe456&#39; as signed);+--------------------------+| cast(&#39;qwe456&#39; as signed) |+--------------------------+|                        0 |+--------------------------+1 row in set, 1 warning (0.00 sec)# 将字符串123qwe456转换为整数mysql&amp;gt; select cast(&#39;123qwe456&#39; as signed);+-----------------------------+| cast(&#39;123qwe456&#39; as signed) |+-----------------------------+|                         123 |+-----------------------------+1 row in set, 1 warning (0.00 sec)# 将字符串123.66qwe456转换为整数mysql&amp;gt; select cast(&#39;123.66qwe456&#39; as signed);+--------------------------------+| cast(&#39;123.66qwe456&#39; as signed) |+--------------------------------+|                            123 |+--------------------------------+1 row in set, 1 warning (0.00 sec)# 将字符串123.66qwe456转换为浮点数mysql&amp;gt; select cast(&#39;123.66qwe456&#39; as float);+-------------------------------+| cast(&#39;123.66qwe456&#39; as float) |+-------------------------------+|                        123.66 |+-------------------------------+1 row in set, 1 warning (0.00 sec)隐式转换数字与字符串的相互转换MySQL会在必要的时候将数字转换为字符串，或将字符串转换为数字。# 数字转换为字符串mysql&amp;gt; select concat(2, &#39;test&#39;);+-------------------+| concat(2, &#39;test&#39;) |+-------------------+| 2test             |+-------------------+1 row in set (0.00 sec)# 字符串转换为数字mysql&amp;gt; select 1 + &#39;1&#39;;+---------+| 1 + &#39;1&#39; |+---------+|       2 |+---------+1 row in set (0.00 sec)# 字符串转换为数字mysql&amp;gt; select 6 &amp;gt; &#39;3qwe&#39;;+------------+| 6 &amp;gt; &#39;3qwe&#39; |+------------+|          1 |+------------+1 row in set, 1 warning (0.00 sec)# 字符串转换为数字mysql&amp;gt; select 0 = &#39;qwe345&#39;;+--------------+| 0 = &#39;qwe345&#39; |+--------------+|            1 |+--------------+1 row in set, 1 warning (0.00 sec)第一例，concat() 需要的参数为字符串，先将数字 2 转换为字符串 &#39;2&#39; ，再将 &#39;2&#39; 与 &#39;test&#39; 进行拼接得到 &#39;2test&#39; 。第二例，加法运算，先将字符串 &#39;1&#39; 转换为数字 1 ，再做加法得到 2 。第三例，比较运算，先将 &#39;3qwe&#39; 转换为数字 3 ，然后 6 &amp;gt; 3 为真，返回1。第四例，比较运算，先将 &#39;qwe345&#39; 转换为数字 0 ，然后 0 = 0 为真，返回1。下面是第五例的情景：# 有表如下mysql&amp;gt; select * from test1;+-------+-------+-------+| no    | name  | grade |+-------+-------+-------+| 23    | admin |    50 || 24    | admin |    43 || 25    | qwe   |    54 || 25asd | qwe   |    54 |+-------+-------+-------+4 rows in set (0.00 sec)# 表结构如下mysql&amp;gt; desc test1;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| no    | varchar(50) | NO   | PRI | NULL    |       || name  | varchar(50) | YES  |     | NULL    |       || grade | smallint(6) | YES  |     | NULL    |       |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec)# 执行查询如下mysql&amp;gt; select * from test1 where no = 25;+-------+------+-------+| no    | name | grade |+-------+------+-------+| 25    | qwe  |    54 || 25asd | qwe  |    54 |+-------+------+-------+2 rows in set, 1 warning (0.00 sec)上面的情景中，执行 where no = 25 时，先看第一行，将字符串 &#39;23&#39; 转换为数字 23 ， 23 = 25 为假，不选该行；然后一样， 24 = 25 为假，不选该行；第三行，将字符串 &#39;25&#39; 转换为数字 25 ， 25 = 25 为真，选中该行；第四行，将字符串 25asd 转换为数字 25 ， 25 = 25 为真，选中该行；最后得到上面的查询结果。总转换规则下面的规则更详细精确，是来自官方文档的描述。The following rules describe how conversion occurs for comparison operations:      If one or both arguments are NULL, the result of the comparison is NULL, except for the NULL-safe &amp;lt;=&amp;gt; equality comparison operator. For NULL &amp;lt;=&amp;gt; NULL, the result is true. No conversion is needed.        If both arguments in a comparison operation are strings, they are compared as strings.        If both arguments are integers, they are compared as integers.        Hexadecimal values are treated as binary strings if not compared to a number.        If one of the arguments is a TIMESTAMP or DATETIME column and the other argument is a constant, the constant is converted to a timestamp before the comparison is performed. This is done to be more ODBC-friendly. This is not done for the arguments to IN(). To be safe, always use complete datetime, date, or time strings when doing comparisons. For example, to achieve best results when using BETWEEN with date or time values, use CAST() to explicitly convert the values to the desired data type.    A single-row subquery from a table or tables is not considered a constant. For example, if a subquery returns an integer to be compared to a DATETIME value, the comparison is done as two integers. The integer is not converted to a temporal value. To compare the operands as DATETIME values, use CAST() to explicitly convert the subquery value to DATETIME.        If one of the arguments is a decimal value, comparison depends on the other argument. The arguments are compared as decimal values if the other argument is a decimal or integer value, or as floating-point values if the other argument is a floating-point value.        In all other cases, the arguments are compared as floating-point (double-precision) numbers. For example, a comparison of string and numeric operands takes place as a comparison of floating-point numbers.  复制自 mysql 类型自动化转换问题 - whendream - 博客园 的翻译：比较运算时的类型转换规则：  如果一个或两个参数都是NULL，比较的结果是NULL，除了NULL安全的&amp;lt;=&amp;gt;相等比较运算符。对于NULL &amp;lt;=&amp;gt; NULL，结果为true。不需要转换。  如果比较操作中的两个参数都是字符串，则将它们作为字符串进行比较。  如果两个参数都是整数，则将它们作为整数进行比较。  如果不与数字进行比较，则将十六进制值视为二进制字符串。  如果其中一个参数是十进制值，则比较取决于另一个参数。 如果另一个参数是十进制或整数值，则将参数与十进制值进行比较，如果另一个参数是浮点值，则将参数与浮点值进行比较。  如果其中一个参数是TIMESTAMP或DATETIME列，另一个参数是常量，则在执行比较之前将常量转换为时间戳。  我的翻译：在所有其它情况下，参数作为浮点数（双精度）进行比较。例如，字符串和数字的比较就作为浮点数进行比较。"
  },
  
  {
    "title": "jekyll-chirpy-theme-github搭建个人博客",
    "url": "/posts/jekyll-chirpy-theme-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/",
    "categories": "Tech, Misc",
    "tags": "",
    "date": "2022-02-05 14:43:00 +0800",
    





    "snippet": "本地写了不少markdown笔记，一直想自己建一个网站。最初的想法是完完全全自己写一个个人网站，全部自定义，不仅可以有技术笔记栏目还可以有其它记录感想，发表观点，发布工具的栏目。然而时间并不总是能自定义，总有些更优先的事项排在前面，加之自己技术水平还没成长到这个程度，于是退而求其次，选择已有框架搭建一个个人博客，先用之，毕竟都要毕业了，连个像样的博客都没有，实在说不过去。我并未放弃建站的想法，说不定以后就有了。安装博客生成器由于kali环境齐全，所以直接在kali下安装本地博客# 安装jekyllsudo gem install jekyll# 安装chirpy主题git clone git@github.com:cotes2020/jekyll-theme-chirpy.git# 在jekyll-theme-chirpy目录下安装依赖# 不需要sudo，命令会在需要时自动调用sudobundle installjekyll-theme-chirpy文件夹就是一个博客生成器，接下来生成本地初始博客。生成初始博客生成博客# 在jekyll-theme-chirpy目录下生成博客，站点取名为lcatmiao.github.io，这里我取的名与后面要创建的# 远程库的名字一致，其实也可以不一致。# jekyll serve命令自动生成名为_site的站点。-d指定生成路径，同时可以重命名站点文件夹名字。sudo jekyll serve -d lcatmiao.github.io# 然后Ctrl + C关闭服务可以看到已经生成了初始博客lcatmiao.github.io# 再次执行jekyll serve命令，这次我们看一下初始博客的样子再关闭服务。# 下面的命令会再一次生成lcatmiao.github.io文件夹，覆盖现有的，反正我们没做什么更改，覆盖# 就覆盖，无妨。# 默认情况下，只有本机才能访问jekyll服务，同一局域网下的其它主机访问不了。# 加上--host 0.0.0.0后同一局域网下的其它主机就可以访问服务了。这里我的kali是虚拟机，# 与本机之间是NAT模式。执行下面的命令后，可以在本机的浏览器中访问kali的网页。sudo jekyll serve -d lcatmiao.github.io --host 0.0.0.0本机浏览器中输入虚拟机IP，端口号4000，可以浏览到初始博客的样子。关闭服务。创建远程库关于github不多赘述。登录github，创建空仓库，为公开库，名字必须为username.github.io，username为github的用户名。推送初始博客# 进入本地lcatmiao.github.io目录# 初始化本地库sudo git init# 添加暂存区sudo git add .# 提交本地库sudo git commit -m &quot;Initialize the blog&quot; .# 添加远程库sudo git remote add lcatmiao.github.io 库链接# 详细查看远程库sudo git remote -v# 推送远程库sudo git push lcatmiao.github.io master刷新远程库，可以看见初始博客已经被推送上来，访问username.github.io就能访问到自己的初始博客页面。修改配置改_config.yml在jekyll-theme-chirpy目录下修改_config.yml。该文件中的注释描述很清楚，自己看着改。配合 jekyll serve 命令在本地查看修改后页面的效果。改faviconfavicon路径：jekyll-theme-chirpy/assets/img/favicons/准备好图片，然后在https://realfavicongenerator.net/生成，下载后解压，在解压后的文件夹中删除browserconfig.xml和site.webmanifest，然后将剩下的东西复制到jekyll-theme-chirpy/assets/img/favicons/删除最近更新栏最近更新栏似乎没有正常工作，查了很多资料也测试了很久，不知道问题出哪了，我决定删除它。在jekyll-theme-chirpy/_layouts/page.html中  &amp;lt;!-- pannel --&amp;gt;  &amp;lt;div id=&quot;panel-wrapper&quot; class=&quot;col-xl-3 pl-2 text-muted&quot;&amp;gt;    &amp;lt;div class=&quot;access&quot;&amp;gt;      {% include update-list.html %}      {% include trending-tags.html %}    &amp;lt;/div&amp;gt;    {% for _include in layout.pannel_includes %}      {% assign _include_path = _include | append: &#39;.html&#39; %}      {% include {{ _include_path }} %}    {% endfor %}  &amp;lt;/div&amp;gt;删除{% include update-list.html %}推送远程库# 在lcatmiao.github.io目录下sudo git add .sudo git commit -m &quot;Personalize some configs&quot; .sudo git push lcatmiao.github.io master访问username.github.io查看页面。放上内容放入自己的文章jekyll-theme-chirpy/_posts就是我们放置md文件的位置。该目录下已有一些文章，这些是博客主题自带的教程，我们不删除，将它们重命名，在每一个文件名前加一个 # ，这样既可以保留这些文件，又可以避免在博客中呈现它们。下面就可以把我们自己的md文件放进去，md文件可以加上一个 yaml头 ，以启用更多功能。关于 yaml头，直接打开这几个主题自带的md文件看看怎么写就行。放入自己的md后，按照主题自带md文件的命名格式命名。# 重新生成博客站点，打开服务# 在jekyll-theme-chirpy下sudo jekyll serve -d lcatmiao.github.io --host 0.0.0.0本地浏览新生成的页面。推送远程库# 在lcatmiao.github.io下sudo git add .sudo git commit .# commit msgAdd git如何合并分支.mdRename the theme&#39;s own md files so that I can keep them and avoid presenting them inthe blog. Besides, add my own md file, git如何合并分支.md.# 推送远程库sudo git push lcatmiao.github.io masterwindows备份因为博客生成器和博客站点都放在虚拟机kali中，而虚拟机经常要回滚，所以我将整个jekyll-theme-chirpy目录在本机windows中备份一份。附jekyll命令# 打开服务，只有本机能够访问网站# 会生成_site目录# 自动监测变化jekyll serve# 指定生成路径和目录名jekyll serve -d ~/myblog# 局域网内其它主机可访问网站jekyll serve --host 0.0.0.0# 指定端口jekyll serve --port 4001# 后台运行# 不能监测变化jekyll serve --detach"
  },
  
  {
    "title": "关于域名的各种名词叫法",
    "url": "/posts/%E5%85%B3%E4%BA%8E%E5%9F%9F%E5%90%8D%E7%9A%84%E5%90%84%E7%A7%8D%E5%90%8D%E8%AF%8D%E5%8F%AB%E6%B3%95/",
    "categories": "Tech, Misc",
    "tags": "",
    "date": "2022-01-29 17:31:10 +0800",
    





    "snippet": "关于域名有一些名词，比如域名、顶级域名、二级域名、三级域名、子域名、主机名等。自己总是搞不清这些名词具体指代什么，因为网上的资料总是有各种差别，同一个名词在不同的资料里有不同的解释，属实是迷惑。在查阅了很多资料后，决定做一个总结，尽可能涵盖各种说法，做一个自己理解的标准，以期在遇到这些说法时心里有底。资料基本概念 (aliyun.com)Domain name - WikipediaWhat’s in a Domain Name? All About Domain Levels - Hover Blog下面贴两段我认为有帮助的描述阿里云产品文档基本概念 (aliyun.com)互联网名称与数字地址分配机构（ICANN）负责管理和协调国际互联网络域名系统。根据ICANN的定义，一个完整的域名至少有两个部分，各部分之间用“.”来分隔，最后一个“.”的右边部分称为顶级域名，也称为一级域名；最后一个“.”的左边部分称为二级域名；二级域名的左边部分称为三级域名，以此类推，每一级的域名控制它下一级域名的分配。下图以www.example.com.cn为例，为您介绍域名的级别。注册域名过程中，可自定义的内容在域名后缀的左侧部分。根据注册局规则，可供用户选择的后缀，可能是顶级域名（如“.cn”），也可能是二级域名（如“.com.cn/.net.cn/.org.cn”）。域名解析设置是针对已经完成注册的域名或已注册域名的左侧部分（即域名后缀左侧的左侧）进行解析设置。 所以在解析场景下，对用户解析内容设置的到底是第几个左侧的解释会存在困难。因此，解析场景里，用户注册的完整域名被定义为“一级域名”（不是顶级域名），完整域名的左侧第一个（即一级域名的子域名）是二级域名，以此类推。以注册一个后缀为“.org.cn”、完整域名为“sample.org.cn”的域名为例，对各定义进行如下说明。  域名后缀：“.org.cn”为注册局提供的可注册的域名后缀。  一级域名：“sample.org.cn”为用户注册的完整域名，即解析场景下的一级域名。  二级域名：“abc.sample.org.cn”为“sample.org.cn”的子域名，即解析场景下的二级域名。维基百科Domain name - Wikipedia在Purpose的第一段有：Individual Internet host computers use domain names as host identifiers, also called hostnames. The term hostname is also used for the leaf labels in the domain name system, usually without further subordinate domain name space. Hostnames appear as a component in Uniform Resource Locators (URLs) for Internet resources such as websites (e.g., en.wikipedia.org).在Second-level and lower level domains的第三段有：Second-level (or lower-level, depending on the established parent hierarchy) domain names are often created based on the name of a company (e.g., bbc.co.uk), product or service (e.g. hotmail.com). Below these levels, the next domain name component has been used to designate a particular host server. Therefore, ftp.example.com might be an FTP server, www.example.com would be a World Wide Web server, and mail.example.com could be an email server, each intended to perform only the implied function.总结https://www.example.com.cn/detail/index.html?id=6以上面这个链接为例，https是协议 ，/detail/index.html是路径，id=6是参数。www.example.com.cn这一整个是域名，也是主机名；cn是顶级域名（一级域名）；com是二级域名，也可以说com.cn是二级域名；example是三级域名，也可以说example.com.cn是三级域名；www是四级域名，也可以说www.example.com.cn是四级域名。com是cn的子域名，example是com的子域名，example是com.cn的子域名，www是example.com.cn的子域名，www.example.com.cn是example.com.cn的子域名，这里说法比较随意，子域名是一个相对概念，想象一下树结构就行。example.com.cn是花钱买的部分，是用户注册的部分，买来以后可以设置子域名，比如www。www是自定义的名字，是服务名，可用于指明服务器提供的服务，例如www、ftp、mail；还可以叫它主机名，不过这个叫法与上面提到的“整个域名也是主机名”是两回事。本例中，www也是四级域名。我们平时看到的域名大都以com、cn、org单个结尾，类似下面这样：www.baidu.comwww.360.cnwww.kali.org但也有以com.cn、net.cn、org.cn两个结尾的，如：yz.chsi.com.cnwww.yto.net.cnwww.cnvd.org.cn本例www.example.com.cn便是以com.cn两个结尾的。com.cn、net.cn、org.cn这种看作二级域名，而不是作为整体看作顶级域名（一级域名）。域名后缀可以是顶级域名（一级域名），也可以是二级域名，前三个例子中，com、cn、org是域名后缀，后三个例子中，com.cn、net.cn、org.cn是域名后缀。本例www.example.com.cn中com.cn是域名后缀。关于一级域名、二级域名等还有另一种说法。以www.example.com.cn为例。将用户注册的完整域名叫做一级域名（不能叫顶级域名），随后逐级下降。example.com.cn是一级域名；www是二级域名，也可以说www.example.com.cn是二级域名。"
  },
  
  {
    "title": "git如何合并分支",
    "url": "/posts/git%E5%A6%82%E4%BD%95%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF/",
    "categories": "Tech, Nuggets",
    "tags": "git",
    "date": "2022-01-26 13:49:37 +0800",
    





    "snippet": "复制了官网文档中对git合并过程的描述，提取了有必要记录的部分；自己测试了一些关于合并冲突的例子，做一个简要总结。  参考资料：Git 分支 - 分支的新建与合并合并过程快进(fast-forward)现在要将hotfix分支合并到master分支。$ git checkout master$ git merge hotfixUpdating f42c576..3a0874cFast-forward index.html | 2 ++ 1 file changed, 2 insertions(+)合并后如下图：当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。随后可以删除hotfix分支。$ git branch -d hotfix三方合并现在要将iss53分支合并到master分支。$ git checkout masterSwitched to branch &#39;master&#39;$ git merge iss53Merge made by the &#39;recursive&#39; strategy.index.html |    1 +1 file changed, 1 insertion(+)合并后如下图：在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的公共祖先（C2），做一个简单的三方合并。Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。随后可以删除iss53分支。$ git branch -d iss53合并冲突如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们，即会产生合并冲突。  fast-forward 一定不会产生合并冲突。  三方合并可能产生合并冲突。合并冲突的发生有点玄学，不必过于纠结，按照第一段话理解即可。具体会不会发生冲突，老老实实听git的就行，它说冲突那就是冲突了。附上一些实测例子：  git版本：git version 2.34.1.windows.1例一直接fast-forward例二PS E:\\2.学习\\test&amp;gt; git merge hotfixAuto-merging merge.txtMerge made by the &#39;ort&#39; strategy. merge.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)我的理解：master对第一行做了修改，但hotfix没有对第一行做修改，无冲突；两分支都没有对第二行做修改，无冲突；master没有对第三行做修改，但hotfix对第三行做了修改，无冲突。最后合并成功，没有冲突。例三PS E:\\2.学习\\test&amp;gt; git merge hotfixAuto-merging merge.txtCONFLICT (content): Merge conflict in merge.txtAutomatic merge failed; fix conflicts and then commit the result.&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEADqwe222qwe=======qweqwe444&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; hotfixqwe我的理解：这个居然会发生冲突，我是没有想到的。原本应该像例二一样理解，第一行只有master改了，第二行只有hotfix改了，第三行两个分支都没改，应该不会出现冲突。然而却出现了冲突，说明冲突的判定没有想象得那么简单，与git的具体实现有关。这里贴出了git插入的冲突标记。按我的理解，根据冲突标记，git认为两个分支对merge.txt的红框处做了不同修改，产生了冲突；蓝框处两者都没有修改，无冲突；所以最终发生了合并冲突。例四PS E:\\2.学习\\test&amp;gt; git merge hotfixAuto-merging merge.txtCONFLICT (content): Merge conflict in merge.txtAutomatic merge failed; fix conflicts and then commit the result.qwe&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEADqwe222qwe=======qweqwe444&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; hotfix同例三。例五PS E:\\2.学习\\test&amp;gt; git merge hotfixAuto-merging merge.txtCONFLICT (content): Merge conflict in merge.txtAutomatic merge failed; fix conflicts and then commit the result.&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEADqwe666=======qwe444&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; hotfixqwe333qwe555我的理解：这个好理解。两个分支对第二行、第三行做了相同的修改，没有冲突；两个分支分别对第一行做了不同的修改，有冲突；最终发生合并冲突。例六PS E:\\2.学习\\test&amp;gt; git merge hotfixAuto-merging merge.txtCONFLICT (content): Merge conflict in merge.txtAutomatic merge failed; fix conflicts and then commit the result.qwe444qwe333&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEADqwe=======qwe555&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; hotfix我的理解：我迷惑了。。。按照之前的理解，两分支对第一行、第二行做了相同的修改，不冲突；master分支没有对第三行做出修改，hotfix分支对第三行做了修改，不冲突；最终应该不冲突才是。假如将这里master分支对第三行的修改看成是“不变的修改”，那么确实可以说两个分支对第三行做了不同的修改，进而发生冲突。但是这样的说法在例二中就站不住脚，按照这个“不变的修改”的假设，例二应该发生冲突才是。想想也是，这个想法是我凭空想象出来的，多半不可能。总结关于合并冲突的判定没有搞懂，不过我认为继续纠结这个问题没有更多的意义了，除非阅读git实现的源码。总而言之，git官方文档的book中有如下描述：Git 分支 - 分支的新建与合并如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。以这句话为标准即可，具体看git的合并结果就行。"
  },
  
  {
    "title": "原码-反码-补码范围及特殊情况",
    "url": "/posts/%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81%E8%8C%83%E5%9B%B4%E5%8F%8A%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5/",
    "categories": "Tech, Misc",
    "tags": "",
    "date": "2021-08-24 15:40:00 +0800",
    





    "snippet": "这篇简单的笔记是考研复习期间写的。尽管考不上了，这篇笔记还是有点价值，记录了几个特殊情况和一些个性化的理解。网上资料较为零散，这里把它们集中说了一下，不过格式比较随意，一些推导方式并不正确但是能帮助理解记忆。一个字节：原码：$-127 \\sim -0, +0 \\sim +127$$-\\frac{127}{128} \\sim -\\frac{0}{128}, +\\frac{0}{128} \\sim +\\frac{127}{128}$$-(1 - 2^{-7}) \\sim -0.000, +0.000 \\sim +(1 - 2^{-7})$$-0.127 \\sim -0.000, +0.000 \\sim +0.127$反码：$-127 \\sim -0, +0 \\sim +127$$-\\frac{127}{128} \\sim -\\frac{0}{128}, +\\frac{0}{128} \\sim +\\frac{127}{128}$$-(1 - 2^{-7}) \\sim -0.000, +0.000 \\sim +(1 - 2^{-7})$$-0.127 \\sim -0.000, +0.000 \\sim +0.127$补码：$-128 \\sim 0 \\sim +127$$-1.0 \\sim 0.000 \\sim +\\frac{127}{128}$$-1.0 \\sim 0.000 \\sim +(1 - 2^{-7})$$-0.128 \\sim 0 \\sim +0.127$原码反码区分±0，±0.0$[+0]_补=[-0]_补=0,000\\ 0000$$[+0.0]_补=[-0.0]_补=0.000\\ 0000$$[-128]_补=1,000\\ 0000$$[-1.0]_补=1.000\\ 0000$      $[+0]_补 \\ \\&amp;amp;\\  [-0]_补$    $[+0]_原=0,000\\ 0000$    $[+0]_补=0,000\\ 0000$    $[-0]_原=1,000\\ 0000$    $[-0]_反=1,111\\ 1111$    $[-0]_补=10,000\\ 0000 \\xlongequal{溢出丢弃}0,000\\ 0000$    $[+0]_补=[-0]_补=0,000\\ 0000$        $[+0.0]_补 \\ \\&amp;amp;\\ [-0.0]_补$    $[+0.0]_原=0.000\\ 0000$    $[+0.0]_补=0.000\\ 0000$    $[-0.0]_原=1.000\\ 0000$    $[-0.0]_反=1.111\\ 1111$    $[-0.0]_补=10.000\\ 0000 \\xlongequal{溢出丢弃}0.000\\ 0000$    $[+0.0]_补=[-0.0]_补=0.000\\ 0000$        $[-128]_补$    $[-128]_{伪原}=1,1000\\ 0000$    $[-128]_{伪反}=1,0111\\ 1111$    $[-128]_补=1,1000\\ 0000 \\xlongequal{溢出丢弃}1,000\\ 0000$        $[-1.0]_补$    $-1.0\\rightarrow-0.128$    $[-1.0]_{伪原}=1.1000\\ 0000$    $[-1.0]_{伪反}=1.0111\\ 1111$    $[-1.0]_补=1.1000\\ 0000 \\xlongequal{溢出丢弃}1.000\\ 0000$  "
  },
  
  {
    "title": "手动搭建Web服务器环境",
    "url": "/posts/%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BAWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83/",
    "categories": "Tech, Misc",
    "tags": "",
    "date": "2020-07-25 16:30:00 +0800",
    





    "snippet": "看网上的教程大都是使用PHPStudy等集成包一键搭建的Web环境，使用集成包搭建是能省不少事，但是也少看见了很多东西，这样就不能自己安排，不喜欢这种感觉。我这里是在VM虚拟机的Win7下进行的，其它Windows系统大同小异，其实在Windows Server之类的系统上搭建应该更好。  本文采用Apache+PHP+MySQL进行配置，版本如下：  Apache 2.4.43  PHP 7.4.8 Thread Safe  MySQL 8.0.21  配置期间若出现“缺少VC环境”或“缺少.NET Framework”，自行百度，微软官网安装Apache配置首先下载安装包https://www.apachelounge.com/download/，是一个压缩包。然后创建一个文件夹放置Web服务环境资源，我这里是D:\\Server随后解压到Server文件夹下，这里解压后文件夹的名字叫做Apache24附一张全部搭建完后的Server文件夹的图，其中的PHP，MySQL，www文件夹会在后面创建。开始配置用记事本打开D:\\Server\\Apache24\\conf\\httpd.conf，这是Apache的配置文件。修改以下条目，可按Ctrl+F查找ServerRoot（Apache的根目录）：d:/Server/Apache24，这里更改SRVROOT变量即可Define SRVROOT &quot;c:/Apache24&quot;ServerRoot &quot;${SRVROOT}&quot;改为Define SRVROOT &quot;d:/Server/Apache24&quot;ServerRoot &quot;${SRVROOT}&quot;ServerName（主机名）：localhost:80，去掉#才能让设置生效# If your host doesn&#39;t have a registered DNS name, enter its IP address here.##ServerName www.example.com:80改为# If your host doesn&#39;t have a registered DNS name, enter its IP address here.#ServerName localhost:80DocumentRoot（Apache默认的网页目录）：d:/Server/www原先默认的网页目录是d:\\Server\\Apache24\\htdocs，我这里更改了，新建了d:\\Server\\www文件夹以存放网页，所以要更改DocumentRoot把d:\\Server\\Apache24\\htdocs下的index.html复制到d:\\Server\\www下，以备后续测试# DocumentRoot: The directory out of which you will serve your# documents. By default, all requests are taken from this directory, but# symbolic links and aliases may be used to point to other locations.#DocumentRoot &quot;${SRVROOT}/htdocs&quot;&amp;lt;Directory &quot;${SRVROOT}/htdocs&quot;&amp;gt;改为# DocumentRoot: The directory out of which you will serve your# documents. By default, all requests are taken from this directory, but# symbolic links and aliases may be used to point to other locations.#DocumentRoot &quot;d:/Server/www&quot;&amp;lt;Directory &quot;d:/Server/www&quot;&amp;gt;DirectoryIndex（Apache默认的入口网页）：这里没做更改，就用的默认的index.html没做更改&amp;lt;IfModule dir_module&amp;gt;    DirectoryIndex index.html&amp;lt;/IfModule&amp;gt;如果要更改，可以改为&amp;lt;IfModule dir_module&amp;gt; DirectoryIndex index.php index.html index.htm&amp;lt;/IfModule&amp;gt;index.php index.html index.htm三个文件是有优先关系的，例：若同时有index.php index.html，则默认访问index.php若只有index.html，则默认访问index.htmlScriptAlias（没研究过，反正是个路径）：这里没做更改之前设置ServerRoot的时候，更改过SRVROOT变量为d:/Server/Apache24，而cgi-bin是Apache24下的一个文件夹，这里只要符合cgi-bin的路径即可。我已经符合，故不修改。没做更改ScriptAlias /cgi-bin/ &quot;${SRVROOT}/cgi-bin/&quot;往下几行还有这个，也没改&amp;lt;Directory &quot;${SRVROOT}/cgi-bin&quot;&amp;gt;    AllowOverride None    Options None    Require all granted&amp;lt;/Directory&amp;gt;接下来双击运行D:\\Server\\Apache24\\bin\\httpd.exe，出现了一个没有任何输出的黑窗体，且不会闪退。这其实意味着打开了Apache服务器，不要关闭黑窗体，下面测试：在虚拟机中打开Google Chrome，地址栏输入localhost，可以访问到如下页面在物理机的浏览器中输入虚拟机IP地址也可访问到相同页面（cmd里ipconfig命令可查询IP）  若是没在虚拟机里安装，全部安在物理机也一样，打开浏览器输入localhost，可以访问到上述页面出现It works!说明应该没什么大问题了，关闭黑窗体，接下来把httpd.exe装到Windows服务里。打开cmd，进入httpd.exe所在目录，输入httpd -k install安装服务。  若想删除服务，可以以管理员身份运行cmd用sc delete Apache2.4命令删除安装成功后，在桌面的“计算机”上右键–管理–服务和应用程序–服务，可以查看所有服务，其中就有Apache2.4服务。在该服务上右键-属性，有一个启动类型选项，默认是自动（开机自启），由于只是学习使用，所以我改成了手动，以后可以在该服务上右键-启动来自行控制它。方便起见，我将D:\\Server\\Apache24\\bin下的ApacheMonitor添加到了开始菜单中，这是一个操控Apache服务的图形化界面，打开后在电脑右下角的小图标里找到它，右键-open，界面如下：PHP配置下载安装包https://windows.php.net/download#php-7.4下载Thread Safe版本，否则后期可能缺少php7apache2_4.dll将zip压缩包解压为D:\\Server\\PHP在D:\\Server\\PHP下有这样两个文件：php.ini-development和php.ini-production两个都是PHP的配置文件，https://www.php.net/manual/zh/migration53.ini.phpphp.ini-development包含在开发环境中推荐使用的设置php.ini-production包含在生产环境中推荐使用的设置这里使用php.ini-production，复制更名为php.ini放在同一目录下，以记事本打开开始配置extension_dir（PHP扩展包目录）：; On windows:;extension_dir = &quot;ext&quot;改为; On windows:extension_dir = &quot;ext&quot;  对于低版本的 PHP，这里 extension_dir 要写绝对路径，例如：  extension_dir = &quot;D:\\Development\\PHP_5.6.0\\ext&quot;。  可以通过 phpinfo 验证下文中开启的扩展是否成功开启，从而确定 extension_dir 是否生效。date.timezone（设置时区）：;date.timezone =改为date.timezone = PRCdefault_charset（设置编码）：没有更改，就用默认的UTF-8default_charset = &quot;UTF-8&quot;开启扩展：网上搜了几个常用的扩展，去掉分号开启，功能可查官方文档php_curl.dll                https://www.php.net/manual/zh/book.curl.phpphp_gd2.dll                https://www.php.net/manual/zh/book.image.phpphp_fileinfo.dll          https://www.php.net/manual/zh/book.fileinfo.phpphp_mbstring.dll      https://www.php.net/manual/zh/book.mbstring.phpphp_pdo_mysql.dll   https://www.php.net/manual/zh/ref.pdo-mysql.phpphp_mysqli.dll           https://www.php.net/manual/zh/book.mysqli.php;extension=curl;extension=gd2;extension=fileinfo;extension=mbstring;extension=pdo_mysql;extension=mysqli改为extension=curlextension=gd2extension=fileinfoextension=mbstringextension=pdo_mysqlextension=mysqli为Apache服务添加PHP支持：在此前的httpd.conf文件的最下面添加如下代码：# php7 supportLoadModule php7_module &quot;D:/Server/PHP/php7apache2_4.dll&quot;AddType application/x-httpd-php .php .html .htm# configure the path to php.iniPHPIniDir &quot;D:/Server/PHP&quot;在D:\\Server\\www下新建index.txt文件，输入如下代码&amp;lt;?php    phpinfo();?&amp;gt;更改扩展名为.php，重启先前的Apache服务用浏览器访问localhost/index.php，可得PHP详细信息页面至此就基本没有大问题了下面配置PHP环境变量，这是为了方便在cmd里直接使用PHP，也可以不配置计算机右键-属性-高级系统设置-环境变量，新建系统变量再打开Path系统变量，在后面加上%PHP_HOME%随后在cmd中测试，输入php -version，会显示版本信息，说明配置成功MySQL配置直接下载的离线安装包https://dev.mysql.com/downloads/installer/，跟着下一步下一步，感觉没啥特殊的配置新建MySQL文件夹，D:\\Server\\MySQL选择custom自定义安装，根据需要选择相应组件，我选择装了MySQL Server 8.0；MySQL Shell 8.0；MySQL Notifier 1.1；MySQL Workbench 8.0 CE；Connector ODBC 8.0；Connector C++ 8.0；Connector J 8.0；Connector NET 8.0；MySQL Documentation 8.0；后面就一直“下一步”，除了让你设置密码的时候要设置一下  MySQL卸载可能有点麻烦，这里不赘述，最好一遍成功，下面是遇到的一些坑：      安装组件时，右下角有个Advanced Options选项，很容易忽略，里面可以设置自定义安装路径，且每个组件都要单独设置一遍，不清楚的可以看这个https://blog.csdn.net/qq_40764966/article/details/96702490    安装前确保磁盘空间足够，因为我是在虚拟机里安装，一开始又错装到了C盘，碰巧C盘剩余1G不到，所以提示Fail了  正常安装完后，在计算机右键-管理-服务中可以看到名为MySQL80的服务，可以选择设为手动启动另外，MySQLNotifier就是一个跟ApacheMonitor差不多的东西，也可以通过它开启服务下面测试：在D:\\Server\\www下新建testmysql.txt文件，写上如下代码：&amp;lt;?php    $conn=mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root密码&quot;);    if($conn)        echo &quot;连接success&quot;;    else        echo &quot;连接fail&quot;;?&amp;gt;将txt文件另存为UTF-8编码的文件（要与PHP设置的默认编码一致，否则中文会乱码）更改扩展名为.php，启动Apache服务和MySQL服务，浏览器localhost/testmysql.php访问可得测试成功，至此环境就搭建完了下面配置MySQL环境变量，这是为了方便在cmd里直接使用MySQL，也可以不配置新建系统变量MYSQL_HOME在Path中添加%MYSQL_HOME%\\MySQL Server 8.0\\bin开启MySQL服务，在cmd中输入mysql -h localhost -u root -p，输入密码，若能成功登录，说明配置成功"
  }
  
]

