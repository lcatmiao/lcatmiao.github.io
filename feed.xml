

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://0.0.0.0:4000/</id>
  <title>小黑猫</title>
  <subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle>
  <updated>2025-11-12T16:59:23+08:00</updated>
  <author>
    <name>小黑猫</name>
    <uri>http://0.0.0.0:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://0.0.0.0:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="zh-CN"
    href="http://0.0.0.0:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator>
  <rights> © 2025 小黑猫 </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>你真的搞懂优先级和结合性了吗？</title>
    <link href="http://0.0.0.0:4000/posts/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7/" rel="alternate" type="text/html" title="你真的搞懂优先级和结合性了吗？" />
    <published>2025-11-12T16:44:00+08:00</published>
  
    <updated>2025-11-12T16:44:00+08:00</updated>
  
    <id>http://0.0.0.0:4000/posts/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7/</id>
    <content src="http://0.0.0.0:4000/posts/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7/" />
    <author>
      <name>{"name"=>"小黑猫", "link"=>"https://github.com/lcatmiao"}</name>
    </author>

  
    
    <category term="Tech" />
    
    <category term="C" />
    
  

  
    <summary>
      





      颠覆认知

我们依据运算符的优先级和结合性来判断一个表达式的运算过程，但我们对于优先级和结合性的理解其实存在着广泛误解。

绝大多数教程都是告诉你：


  优先级高的运算符先执行。
  当出现多个优先级相同的运算符时，依据结合性判断运算符的执行顺序。


其实按照上面的说法，将有诸多无法解释的现象，比如：

int main(void)
{
    printf("%c", 'a') + 1 + 1 + (printf("%c", 'b') + printf("%c", 'c'));
    return 0;
}


括号的优先级最高，所以上面的代码应该先打印 b 或者 c，另外，你也无法回答是 b 先被打印还是 c 先被打印。现在揭晓“答案”，上述代码经过 gcc.exe (x86_64-posix-seh-rev0, Built by MinGW-Builds project...
    </summary>
  

  </entry>

  
  <entry>
    <title>五险一金超详细整理</title>
    <link href="http://0.0.0.0:4000/posts/%E4%BA%94%E9%99%A9%E4%B8%80%E9%87%91%E8%B6%85%E8%AF%A6%E7%BB%86%E6%95%B4%E7%90%86/" rel="alternate" type="text/html" title="五险一金超详细整理" />
    <published>2025-08-25T10:53:00+08:00</published>
  
    <updated>2025-08-25T10:53:00+08:00</updated>
  
    <id>http://0.0.0.0:4000/posts/%E4%BA%94%E9%99%A9%E4%B8%80%E9%87%91%E8%B6%85%E8%AF%A6%E7%BB%86%E6%95%B4%E7%90%86/</id>
    <content src="http://0.0.0.0:4000/posts/%E4%BA%94%E9%99%A9%E4%B8%80%E9%87%91%E8%B6%85%E8%AF%A6%E7%BB%86%E6%95%B4%E7%90%86/" />
    <author>
      <name>{"name"=>"小黑猫", "link"=>"https://github.com/lcatmiao"}</name>
    </author>

  
    
    <category term="Society" />
    
  

  
    <summary>
      





      前言

本文正好成文于 2025 年社保新规前，所以有些内容可能刚整理出来就过时了。文中大多数内容均以浙江省政策为例。政策是会变化的，且各地政策不同，本文仅供学习参考。

五险


  
    
      类别
      缴纳
      账户
    
  
  
    
      养老（职工保险）
      个人 + 单位
      个人 + 统筹
    
    
      医疗（职工医保）
      个人 + 单位
      个人 + 统筹
    
    
      失业
      个人 + 单位
      统筹
    
    
      工伤
      单位
      统筹
    
    
      生育
      单位
      统筹
    
  



  统筹账户也叫统筹基金。
  个人账户里的钱都是自己的，至于能...
    </summary>
  

  </entry>

  
  <entry>
    <title>死机定位-内存不足死在vmalloc</title>
    <link href="http://0.0.0.0:4000/posts/%E6%AD%BB%E6%9C%BA%E5%AE%9A%E4%BD%8D-%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E6%AD%BB%E5%9C%A8vmalloc/" rel="alternate" type="text/html" title="死机定位-内存不足死在vmalloc" />
    <published>2025-06-01T20:30:00+08:00</published>
  
    <updated>2025-06-01T20:30:00+08:00</updated>
  
    <id>http://0.0.0.0:4000/posts/%E6%AD%BB%E6%9C%BA%E5%AE%9A%E4%BD%8D-%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E6%AD%BB%E5%9C%A8vmalloc/</id>
    <content src="http://0.0.0.0:4000/posts/%E6%AD%BB%E6%9C%BA%E5%AE%9A%E4%BD%8D-%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E6%AD%BB%E5%9C%A8vmalloc/" />
    <author>
      <name>{"name"=>"小黑猫", "link"=>"https://github.com/lcatmiao"}</name>
    </author>

  
    
    <category term="Tech" />
    
    <category term="Linux" />
    
  

  
    <summary>
      





      定位过程

死机调用栈如下，推栈结果与 bt 结果大差不差。由一个终端程序一路调用到 vmalloc，最后死在其内部。注意到函数 out_of_memory，这表明可能是系统内存快耗尽了。

[0]kdb&amp;gt; bt
Stack traceback for pid 693
0xffff880362416740      693        1  1    0   R  0xffff8803624171c0 *vtysh
[15792.666500]  ffff88042d6bb818 0000000000000018 ffffffff818604c0 ffff88042d6bb858
[15792.755452]  ffffffff8109f38e ffff88042d6bb848 ffffffff817a6588 000000000040adbd
[15792.844406] ...
    </summary>
  

  </entry>

  
  <entry>
    <title>用户态源码反汇编定位方法记录</title>
    <link href="http://0.0.0.0:4000/posts/%E7%94%A8%E6%88%B7%E6%80%81%E6%BA%90%E7%A0%81%E5%8F%8D%E6%B1%87%E7%BC%96%E5%AE%9A%E4%BD%8D%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/" rel="alternate" type="text/html" title="用户态源码反汇编定位方法记录" />
    <published>2025-05-24T21:55:00+08:00</published>
  
    <updated>2025-05-24T21:55:00+08:00</updated>
  
    <id>http://0.0.0.0:4000/posts/%E7%94%A8%E6%88%B7%E6%80%81%E6%BA%90%E7%A0%81%E5%8F%8D%E6%B1%87%E7%BC%96%E5%AE%9A%E4%BD%8D%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/</id>
    <content src="http://0.0.0.0:4000/posts/%E7%94%A8%E6%88%B7%E6%80%81%E6%BA%90%E7%A0%81%E5%8F%8D%E6%B1%87%E7%BC%96%E5%AE%9A%E4%BD%8D%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/" />
    <author>
      <name>{"name"=>"小黑猫", "link"=>"https://github.com/lcatmiao"}</name>
    </author>

  
    
    <category term="Tech" />
    
    <category term="C" />
    
  

  
    <summary>
      





      前言

问题背景就是进程崩溃，产生了 core 文件。其实这次定位非常简单，bt, disassemble 就能直接看出来了。既然简单，就利用这次机会尝试了一下源码反汇编的定位方法。此前在别人的帮助下，运用该方法定位过内核态的问题，但都事发紧急，事后没能复盘，留下了遗憾。尽管存在差异，还是决定在用户态“模拟”一下。

定位过程

Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007fcff9ad157a in check ()
   from ....so
(gdb) bt
#0  0x00007fcff9ad157a in check ()
   from ....so
#1  0x00007fcff9ad27c1 in func ()
   from ....so
#2  0x00007fc...
    </summary>
  

  </entry>

  
  <entry>
    <title>gdb无-g调试实战记录</title>
    <link href="http://0.0.0.0:4000/posts/gdb%E6%97%A0-g%E8%B0%83%E8%AF%95%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/" rel="alternate" type="text/html" title="gdb无-g调试实战记录" />
    <published>2025-04-24T22:00:00+08:00</published>
  
    <updated>2025-04-24T22:00:00+08:00</updated>
  
    <id>http://0.0.0.0:4000/posts/gdb%E6%97%A0-g%E8%B0%83%E8%AF%95%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/</id>
    <content src="http://0.0.0.0:4000/posts/gdb%E6%97%A0-g%E8%B0%83%E8%AF%95%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/" />
    <author>
      <name>{"name"=>"小黑猫", "link"=>"https://github.com/lcatmiao"}</name>
    </author>

  
    
    <category term="Tech" />
    
    <category term="C" />
    
  

  
    <summary>
      





      问题背景

设备外发日志的内容错乱，甚至产生 core 文件。版本是正常编译的发行版本，没有附带 -g 加入的调试信息。

我懒得加调试信息也不想加 -g 重新编译，二者在本人的开发环境中都十分麻烦。这种无 -g 调试的场景其实还蛮常见的，这次定位比较顺利，故记录之。

定位过程

从现象上看是日志内容错位了，但也不能排除是踩内存，出界内容被直接解析也能出现类似的现象。通过看代码，我高度怀疑日志结构体在传参进入函数 output_syslog(log_s *in_buffer) 的时候就已经有问题了。没有 -g 的话，就只能进行有限的调试，通过跟踪地址、强看汇编来定位。

gdb 给怀疑的函数 output_syslog() 打断点，命中后，寄存器信息如下：

(gdb) b output_syslog 
Breakpoint 1 at 0x43ed38
(gdb) c
Contin...
    </summary>
  

  </entry>

</feed>


